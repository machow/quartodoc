[
  {
    "objectID": "examples/index.html",
    "href": "examples/index.html",
    "title": "quartodoc",
    "section": "",
    "text": "Siuba\n\n\n\n\n\n\n\nReference Page\n\n\nSource\n\n\n\n\n\n\n\n\nPins\n\n\n\n\n\n\n\nReference Page\n\n\nSource\n\n\n\n\n\n\n\n\nVetiver\n\n\n\n\n\n\n\nReference Page\n\n\nSource\n\n\n\n\n\n\n\n\nShiny\n\n\n\n\n\n\n\nReference Page\n\n\nSource\n\n\n\n\n\n\n\n\nShinyswatch\n\n\n\n\n\n\n\nReference Page\n\n\nSource\n\n\n\n\n\n Get help creating documentation ⚡️"
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "This screencast walks through the process of build API documentation, by re-creating the pins API documentation from scratch."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "api/MdRenderer.render_header.html",
    "href": "api/MdRenderer.render_header.html",
    "title": "quartodoc",
    "section": "",
    "text": "MdRenderer.render_header\nMdRenderer.render_header(el)\nRender the header of a docstring, including any anchors."
  },
  {
    "objectID": "api/layout.DocFunction.html",
    "href": "api/layout.DocFunction.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.DocFunction\nlayout.DocFunction()\nDocument a python function."
  },
  {
    "objectID": "api/layout.Item.html",
    "href": "api/layout.Item.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.Item()\nInformation about a documented object, including a URI to its location.\nItem is used to creative relative links within a documented API. All of the items for an API are saved as an inventory file (usually named objects.json), so documentation sites can link across each other.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nname\nstr\nThe name of the object.\n\n\nobj\nUnion[dc.Object, dc.Alias]\nA representation of the object (eg its parameters and parsed docstring)\n\n\nuri\nOptional[str]\nA relative URI link to the object from the root of the documentation site.\n\n\ndispname\nOptional[str]\nDefault display name, if none is specified in the interlink. If None, the default is to dipslay the name attribute."
  },
  {
    "objectID": "api/layout.DocAttribute.html",
    "href": "api/layout.DocAttribute.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.DocAttribute\nlayout.DocAttribute()\nDocument a python attribute."
  },
  {
    "objectID": "api/get_object.html",
    "href": "api/get_object.html",
    "title": "quartodoc",
    "section": "",
    "text": "get_object(path, object_name=None, parser='numpy', load_aliases=True, dynamic=False, loader=None)\nFetch a griffe object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr\nAn import path to the object. This should have the form path.to.module:object. For example, quartodoc:get_object or quartodoc:MdRenderer.render.\nrequired\n\n\nobject_name\n‘str | None’\n(Deprecated). A function name.\nNone\n\n\nparser\nstr\nA docstring parser to use.\n'numpy'\n\n\nload_aliases\n\nFor aliases that were imported from other modules, should we load that module?\nTrue\n\n\ndynamic\n\nWhether to dynamically import object. Useful if docstring is not hard-coded, but was set on object by running python code.\nFalse\n\n\n\n\n\n\npreview: print a user-friendly preview of a griffe object.\n\n\n\n>>> get_function(\"quartodoc\", \"get_function\")\n<Function('get_function', ...\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndc.Object\nabc"
  },
  {
    "objectID": "api/layout.ChoicesChildren.html",
    "href": "api/layout.ChoicesChildren.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.ChoicesChildren()\nOptions for how child members of a class or module should be documented.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nembedded\n\nEmbed documentation inside the parent object’s documentation.\n\n\nflat\n\nInclude documentation after the parent object’s documentation.\n\n\nseparate\n\nPut documentation for members on their own, separate pages.\n\n\nlinked\n\nInclude only a table of links to members (which may not be documented)."
  },
  {
    "objectID": "api/Builder.write_doc_pages.html",
    "href": "api/Builder.write_doc_pages.html",
    "title": "quartodoc",
    "section": "",
    "text": "Builder.write_doc_pages\nBuilder.write_doc_pages(pages, filter)\nWrite individual function documentation pages."
  },
  {
    "objectID": "api/layout.ContentElement.html",
    "href": "api/layout.ContentElement.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.ContentElement\nlayout.ContentElement\nEntry in the contents list."
  },
  {
    "objectID": "api/ast.DocstringSectionNotes.html",
    "href": "api/ast.DocstringSectionNotes.html",
    "title": "quartodoc",
    "section": "",
    "text": "ast.DocstringSectionNotes\nast.DocstringSectionNotes()"
  },
  {
    "objectID": "api/Auto.html",
    "href": "api/Auto.html",
    "title": "quartodoc",
    "section": "",
    "text": "Auto()\nConfigure a python object to document (e.g. module, class, function, attribute).\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nname\nstr\nName of the object. This should be the path needed to import it.\n\n\nsignature_name\n\nStyle of name to use in the signature. Can be “relative”, “full”, or “short”. Relative is whatever was used as the name argument, full is the fully qualified path the object, and short is the name of the object (i.e. no periods).\n\n\nmembers\n\nA list of members, such as attributes or methods on a class, to document.\n\n\ninclude_private\n\nWhether to include members starting with “_”\n\n\ninclude_imports\n\nWhether to include members that were imported from somewhere else.\n\n\ninclude_empty\n\nWhether to include members with no docstring.\n\n\ninclude_inherited\n\nWhether to include members inherited from a parent class.\n\n\ninclude_attributes\n\nWhether to include attributes.\n\n\ninclude_classes\n\nWhether to include classes.\n\n\ninclude_functions\n\nWhether to include functions.\n\n\ninclude\n\n(Not implemented). A list of members to include.\n\n\nexclude\n\n(Not implemented). A list of members to exclude.\n\n\ndynamic\n\nWhether to dynamically load docstring. By default docstrings are loaded using static analysis. dynamic may be a string pointing to another object, to return an alias for that object.\n\n\nchildren\n\nStyle for presenting members. Either separate, embedded, or flat.\n\n\npackage\n\nIf specified, object lookup will be relative to this path.\n\n\nmember_options\n\nOptions to apply to members. These can include any of the options above."
  },
  {
    "objectID": "api/ast.DocstringSectionSeeAlso.html",
    "href": "api/ast.DocstringSectionSeeAlso.html",
    "title": "quartodoc",
    "section": "",
    "text": "ast.DocstringSectionSeeAlso\nast.DocstringSectionSeeAlso()"
  },
  {
    "objectID": "api/Builder.write_sidebar.html",
    "href": "api/Builder.write_sidebar.html",
    "title": "quartodoc",
    "section": "",
    "text": "Builder.write_sidebar\nBuilder.write_sidebar(blueprint)\nWrite a yaml config file for API sidebar."
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "quartodoc",
    "section": "",
    "text": "These functions fetch and analyze Python objects, including parsing docstrings. They prepare a basic representation of your doc site that can be rendered and built.\n\n\n\nAuto\nConfigure a python object to document (e.g. module, class, function, attribute).\n\n\nblueprint\nConvert a configuration element to something that is ready to render.\n\n\ncollect\nReturn all pages and items in a layout.\n\n\nget_object\nFetch a griffe object.\n\n\npreview\nPrint a friendly representation of a griffe object (e.g. function, docstring)\n\n\n\n\n\n\nRenderers convert parsed docstrings into a target format, like markdown.\n\n\n\nMdRenderer\nRender docstrings to markdown.\n\n\nMdRenderer.render\nReturn a string representation of an object, or layout element.\n\n\nMdRenderer.render_annotation\nSpecial hook for rendering a type annotation.\n\n\nMdRenderer.render_header\nRender the header of a docstring, including any anchors.\n\n\nMdRenderer.signature\n————————————————————————————————————————————–\n\n\nMdRenderer.summarize\nProduce a summary table.\n\n\n\n\n\n\nBuilders are responsible for building documentation. They tie all the pieces of quartodoc together, and can be defined in your _quarto.yml config.\n\n\n\nBuilder\nBase class for building API docs.\n\n\nBuilder.from_quarto_config\nConstruct a Builder from a configuration object (or yaml file).\n\n\nBuilder.build\nBuild index page, sphinx inventory, and individual doc pages.\n\n\nBuilder.write_index\nWrite API index page.\n\n\nBuilder.write_doc_pages\nWrite individual function documentation pages.\n\n\nBuilder.write_sidebar\nWrite a yaml config file for API sidebar.\n\n\nBuilder.create_inventory\nGenerate sphinx inventory object.\n\n\n\n\n\n\nInventory files map a function’s name to its corresponding url in your docs. These functions allow you to create and transform inventory files.\n\n\n\ncreate_inventory\nReturn a sphinx inventory file.\n\n\nconvert_inventory\nConvert a sphinx inventory file to json.\n\n\n\n\n\n\n\n\nClasses for specifying the broad structure your docs.\n\n\n\nlayout.Layout\nThe layout of an API doc, which may include many pages.\n\n\nlayout.Section\nA section of content on the reference index page.\n\n\nlayout.Page\nA page of documentation.\n\n\nlayout.SectionElement\nEntry in the sections list.\n\n\nlayout.ContentElement\nEntry in the contents list.\n\n\n\n\n\n\nClasses representing python objects to be rendered.\n\n\n\nlayout.Doc\nA python object to be documented.\n\n\nlayout.DocFunction\nDocument a python function.\n\n\nlayout.DocAttribute\nDocument a python attribute.\n\n\nlayout.DocModule\nDocument a python module.\n\n\nlayout.DocClass\nDocument a python class.\n\n\nlayout.Link\nA link to an object (e.g. a method that gets documented on a separate page).\n\n\nlayout.Item\nInformation about a documented object, including a URI to its location.\n\n\nlayout.ChoicesChildren\nOptions for how child members of a class or module should be documented.\n\n\n\n\n\n\nMost of the classes for representing python objects live in griffe.dataclasses or griffe.docstrings.dataclasses. However, the quartodoc.ast module has a number of custom classes to fill in support for some important docstring sections.\n\n\n\nast.DocstringSectionSeeAlso\n\n\n\nast.DocstringSectionNotes\n\n\n\nast.DocstringSectionWarnings\n\n\n\nast.ExampleCode\n\n\n\nast.ExampleText"
  },
  {
    "objectID": "api/MdRenderer.render_annotation.html",
    "href": "api/MdRenderer.render_annotation.html",
    "title": "quartodoc",
    "section": "",
    "text": "MdRenderer.render_annotation(el)\nSpecial hook for rendering a type annotation.\n\n\nel: An object representing a type annotation.\n\nrender_annotation(self, el: NoneType) -> str\n\nrender_annotation(self, el: griffe.expressions.Name) -> str\n\nrender_annotation(self, el: griffe.expressions.Expression) -> str"
  },
  {
    "objectID": "api/create_inventory.html",
    "href": "api/create_inventory.html",
    "title": "quartodoc",
    "section": "",
    "text": "create_inventory(project, version, items, uri=lambda s: f'{s.canonical_path}.html', dispname='-')\nReturn a sphinx inventory file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproject\nstr\nName of the project (often the package name).\nrequired\n\n\nversion\nstr\nVersion of the project (often the package version).\nrequired\n\n\nitems\n‘list[dc.Object | dc.Alias]’\nA docstring parser to use.\nrequired\n\n\nuri\n‘str | Callable[dc.Object, str]’\nLink relative to the docs where the items documentation lives.\nlambda s: f'{s.canonical_path}.html'\n\n\ndispname\n‘str | Callable[dc.Object, str]’\nName to be shown when a link to the item is made.\n'-'\n\n\n\n\n\n\n>>> f_obj = get_object(\"quartodoc\", \"create_inventory\")\n>>> inv = create_inventory(\"example\", \"0.0\", [f_obj])\n>>> inv\nInventory(project='example', version='0.0', source_type=<SourceTypes.Manual: 'manual'>)\nTo preview the inventory, we can convert it to a dictionary:\n>>> _to_clean_dict(inv)\n{'project': 'example',\n 'version': '0.0',\n 'count': 1,\n 'items': [{'name': 'quartodoc.create_inventory',\n   'domain': 'py',\n   'role': 'function',\n   'priority': '1',\n   'uri': 'quartodoc.create_inventory.html',\n   'dispname': '-'}]}"
  },
  {
    "objectID": "api/Builder.html",
    "href": "api/Builder.html",
    "title": "quartodoc",
    "section": "",
    "text": "Builder(self, package, sections=tuple(), options=None, version=None, dir='reference', title='Function reference', renderer='markdown', out_index=None, sidebar=None, rewrite_all_pages=False, source_dir=None, dynamic=None, parser='numpy', render_interlinks=False, _fast_inventory=False)\nBase class for building API docs.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package.\nrequired\n\n\nsections\n‘list[Any]’\nA list of sections, with items to document.\ntuple()\n\n\nversion\n‘str | None’\nThe package version. By default this attempts to look up the current package version (TODO).\nNone\n\n\ndir\nstr\nName of API directory.\n'reference'\n\n\ntitle\nstr\nTitle of the API index page.\n'Function reference'\n\n\nrenderer\n‘dict | Renderer | str’\nThe renderer used to convert docstrings (e.g. to markdown).\n'markdown'\n\n\noptions\n‘dict | None’\nDefault options to set for all pieces of content (e.g. include_attributes).\nNone\n\n\nout_index\nstr\nThe output path of the index file, used to list all API functions.\nNone\n\n\nsidebar\n‘str | None’\nThe output path for a sidebar yaml config (by default no config generated).\nNone\n\n\nrewrite_all_pages\n\nWhether to rewrite all rendered doc pages, or only those with changes.\nFalse\n\n\nsource_dir\n‘str | None’\nA directory where source files to be documented live. This is only necessary if you are not documenting a package, but collection of scripts. Use a “.” to refer to the current directory.\nNone\n\n\ndynamic\nbool | None\nWhether to dynamically load all python objects. By default, objects are loaded using static analysis.\nNone\n\n\nrender_interlinks\nbool\nWhether to render interlinks syntax inside documented objects. Note that the interlinks filter is required to generate the links in quarto.\nFalse\n\n\nparser\n\nDocstring parser to use. This correspond to different docstring styles, and can be one of “google”, “sphinx”, and “numpy”. Defaults to “numpy”.\n'numpy'"
  },
  {
    "objectID": "api/layout.SectionElement.html",
    "href": "api/layout.SectionElement.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.SectionElement\nlayout.SectionElement\nEntry in the sections list."
  },
  {
    "objectID": "api/MdRenderer.html",
    "href": "api/MdRenderer.html",
    "title": "quartodoc",
    "section": "",
    "text": "MdRenderer(self, header_level=1, show_signature=True, show_signature_annotations=False, display_name='relative', hook_pre=None, render_interlinks=False)\nRender docstrings to markdown.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nheader_level\nint\nThe level of the header (e.g. 1 is the biggest).\n1\n\n\nshow_signature\nbool\nWhether to show the function signature.\nTrue\n\n\nshow_signature_annotations\nbool\nWhether to show annotations in the function signature.\nFalse\n\n\ndisplay_name\nstr\nThe default name shown for documented functions. Either “name”, “relative”, “full”, or “canonical”. These options range from just the function name, to its full path relative to its package, to including the package name, to its the its full path relative to its .__module__.\n'relative'\n\n\n\n\n\n\n>>> from quartodoc import MdRenderer, get_object\n>>> renderer = MdRenderer(header_level=2)\n>>> f = get_object(\"quartodoc\", \"get_object\")\n>>> print(renderer.render(f)[:81])\n## get_object\n`get_object(module: str, object_name: str, parser: str = 'numpy')`\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nquartodoc.MdRenderer.style\nstr(object=’’) -> str\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nquartodoc.MdRenderer.render\nReturn a string representation of an object, or layout element.\n\n\nquartodoc.MdRenderer.render_annotation\nSpecial hook for rendering a type annotation.\n\n\nquartodoc.MdRenderer.render_header\nRender the header of a docstring, including any anchors.\n\n\nquartodoc.MdRenderer.signature\n————————————————————————————————————————————–\n\n\nquartodoc.MdRenderer.summarize\nProduce a summary table."
  },
  {
    "objectID": "api/Builder.from_quarto_config.html",
    "href": "api/Builder.from_quarto_config.html",
    "title": "quartodoc",
    "section": "",
    "text": "Builder.from_quarto_config\nBuilder.from_quarto_config(quarto_cfg)\nConstruct a Builder from a configuration object (or yaml file)."
  },
  {
    "objectID": "api/layout.Page.html",
    "href": "api/layout.Page.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.Page()\nA page of documentation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nkind\nLiteral[‘page’]\n\n\n\npath\nstr\nThe file path this page should be written to (without an extension).\n\n\npackage\nUnion[str, None, MISSING]\nIf specified, all object lookups will be relative to this path.\n\n\nsummary\nOptional[SummaryDetails]\nAn optional title and description for the page.\n\n\nflatten\nbool\nWhether to list out each object on this page in the index."
  },
  {
    "objectID": "api/ast.ExampleCode.html",
    "href": "api/ast.ExampleCode.html",
    "title": "quartodoc",
    "section": "",
    "text": "ast.ExampleCode\nast.ExampleCode(value)"
  },
  {
    "objectID": "api/preview.html",
    "href": "api/preview.html",
    "title": "quartodoc",
    "section": "",
    "text": "preview(ast, max_depth=999, compact=False, as_string=False)\nPrint a friendly representation of a griffe object (e.g. function, docstring)\n\n\n>>> from quartodoc import get_object\n>>> obj = get_object(\"quartodoc\", \"get_object\")\n>>> preview(obj.docstring.parsed)\n ...\n>>> preview(obj)\n ..."
  },
  {
    "objectID": "api/layout.Layout.html",
    "href": "api/layout.Layout.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.Layout()\nThe layout of an API doc, which may include many pages.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsections\nlist[Union[SectionElement, Section]]\nTop-level sections of the quarto layout config.\n\n\npackage\nUnion[str, None, MISSING]\nThe package being documented."
  },
  {
    "objectID": "api/MdRenderer.render.html",
    "href": "api/MdRenderer.render.html",
    "title": "quartodoc",
    "section": "",
    "text": "MdRenderer.render\nMdRenderer.render(el)\nReturn a string representation of an object, or layout element.\n\nrender(self, el: str)\n\nrender(self, el: quartodoc.layout.Page)\n\nrender(self, el: quartodoc.layout.Section)\n\nrender(self, el: quartodoc.layout.Interlaced)\n\nrender(self, el: quartodoc.layout.Doc)\n\nrender(self, el: Union[quartodoc.layout.DocClass, quartodoc.layout.DocModule])\n\nrender(self, el: Union[quartodoc.layout.DocFunction, quartodoc.layout.DocAttribute])\n\nrender(self, el: Union[griffe.dataclasses.Object, griffe.dataclasses.Alias])\nRender high level objects representing functions, classes, etc..\n\nrender(self, el: griffe.dataclasses.Parameters)\n\nrender(self, el: griffe.dataclasses.Parameter)\n\nrender(self, el: griffe.docstrings.dataclasses.DocstringSectionText)\n\n\ntext —-\n\n\nnote this can be a number of things. for example, opening docstring text,\n\n\nor a section with a header not included in the numpydoc standard\n\nrender(self, el: griffe.docstrings.dataclasses.DocstringSectionParameters)\n\nrender(self, el: griffe.docstrings.dataclasses.DocstringParameter) -> Tuple[str]\n\nrender(self, el: griffe.docstrings.dataclasses.DocstringSectionAttributes)\n\nrender(self, el: griffe.docstrings.dataclasses.DocstringAttribute)\n\nrender(self, el: griffe.docstrings.dataclasses.DocstringSectionAdmonition)\n\n\nadmonition —-\n\n\nnote this can be a see-also, warnings, or notes section\n\n\nfrom the googledoc standard\n\nrender(self, el: quartodoc.ast.DocstringSectionWarnings)\n\nrender(self, el: quartodoc.ast.DocstringSectionSeeAlso)\n\nrender(self, el: quartodoc.ast.DocstringSectionNotes)\n\nrender(self, el: griffe.docstrings.dataclasses.DocstringSectionExamples)\n\nrender(self, el: quartodoc.ast.ExampleCode)\n\nrender(self, el: quartodoc.ast.ExampleText)\n\nrender(self, el: Union[griffe.docstrings.dataclasses.DocstringSectionReturns, griffe.docstrings.dataclasses.DocstringSectionRaises])\n\nrender(self, el: Union[griffe.docstrings.dataclasses.DocstringReturn, griffe.docstrings.dataclasses.DocstringRaise])\n\nrender(self, el)"
  },
  {
    "objectID": "api/MdRenderer.signature.html",
    "href": "api/MdRenderer.signature.html",
    "title": "quartodoc",
    "section": "",
    "text": "MdRenderer.signature\nMdRenderer.signature(el, source=None)\n\nsignature(self, el: griffe.dataclasses.Alias, source: Optional[griffe.dataclasses.Alias] = None)\nReturn a string representation of an object’s signature.\n\nsignature(self, el: Union[griffe.dataclasses.Class, griffe.dataclasses.Function], source: Optional[griffe.dataclasses.Alias] = None)\n\nsignature(self, el: Union[griffe.dataclasses.Module, griffe.dataclasses.Attribute], source: Optional[griffe.dataclasses.Alias] = None)"
  },
  {
    "objectID": "api/blueprint.html",
    "href": "api/blueprint.html",
    "title": "quartodoc",
    "section": "",
    "text": "blueprint(el, package=None, dynamic=None, parser='numpy')\nConvert a configuration element to something that is ready to render.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nel\n_Base\nAn element, like layout.Auto, to transform.\nrequired\n\n\npackage\nstr\nA base package name. If specified, this is prepended to the names of any objects.\nNone\n\n\ndynamic\nNone | bool\nWhether to dynamically load objects. Defaults to using static analysis.\nNone\n\n\n\n\n\n\n>>> from quartodoc import blueprint\n>>> from quartodoc.layout import Auto\n>>> blueprint(Auto(name = \"quartodoc.get_object\"))\nDocFunction(name='quartodoc.get_object', ...)\n>>> blueprint(Auto(name = \"get_object\"), package = \"quartodoc\")\nDocFunction(name='get_object', ...)"
  },
  {
    "objectID": "api/layout.Doc.html",
    "href": "api/layout.Doc.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.Doc()\nA python object to be documented.\nNote that this class should not be used directly. Instead, use child classes like DocFunction.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nname\nstr\nThe import path of the object (e.g. quartodoc.get_object).\n\n\nobj\nUnion[dc.Object, dc.Alias]\nThe loaded python object.\n\n\nanchor\nstr\nAn anchor named, used to locate this documentation on a quartodoc.layout.Page.\n\n\n\n\n\n\nquartodoc.layout.DocModule, quartodoc.layout.DocClass, quartodoc.layout.DocFunction, quartodoc.layout.DocAttribute"
  },
  {
    "objectID": "api/Builder.write_index.html",
    "href": "api/Builder.write_index.html",
    "title": "quartodoc",
    "section": "",
    "text": "Builder.write_index\nBuilder.write_index(blueprint)\nWrite API index page."
  },
  {
    "objectID": "api/Builder.build.html",
    "href": "api/Builder.build.html",
    "title": "quartodoc",
    "section": "",
    "text": "Builder.build(filter='*')\nBuild index page, sphinx inventory, and individual doc pages.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilter\nstr\nA simple pattern, that may include * as a wildcard. If specified, only doc paths for objects with matching names will be written. Path is the file’s base name in the API dir (e.g. MdRenderer.render)\n'*'"
  },
  {
    "objectID": "api/layout.DocModule.html",
    "href": "api/layout.DocModule.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.DocModule\nlayout.DocModule()\nDocument a python module."
  },
  {
    "objectID": "api/collect.html",
    "href": "api/collect.html",
    "title": "quartodoc",
    "section": "",
    "text": "collect(el, base_dir)\nReturn all pages and items in a layout.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nel\nlayout._Base\nAn element, like layout.Section or layout.Page, to collect pages and items from.\nrequired\n\n\nbase_dir\nstr\nThe directory where API pages will live.\nrequired"
  },
  {
    "objectID": "api/Builder.create_inventory.html",
    "href": "api/Builder.create_inventory.html",
    "title": "quartodoc",
    "section": "",
    "text": "Builder.create_inventory\nBuilder.create_inventory(items)\nGenerate sphinx inventory object."
  },
  {
    "objectID": "api/layout.Section.html",
    "href": "api/layout.Section.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.Section(self, **data)\nA section of content on the reference index page.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nkind\nLiteral[‘section’]\n\n\n\ntitle\nOptional[str]\nTitle of the section on the index.\n\n\nsubtitle\nOptional[str]\nSubtitle of the section on the index. Note that either title or subtitle, but not both, may be set.\n\n\ndesc\nOptional[str]\nDescription of the section on the index.\n\n\npackage\nUnion[str, None, MISSING]\nIf specified, all object lookups will be relative to this path.\n\n\ncontents\nContentList\nIndividual objects (e.g. functions, classes, methods) being documented."
  },
  {
    "objectID": "api/ast.ExampleText.html",
    "href": "api/ast.ExampleText.html",
    "title": "quartodoc",
    "section": "",
    "text": "ast.ExampleText\nast.ExampleText(value)"
  },
  {
    "objectID": "api/ast.DocstringSectionWarnings.html",
    "href": "api/ast.DocstringSectionWarnings.html",
    "title": "quartodoc",
    "section": "",
    "text": "ast.DocstringSectionWarnings\nast.DocstringSectionWarnings()"
  },
  {
    "objectID": "api/convert_inventory.html",
    "href": "api/convert_inventory.html",
    "title": "quartodoc",
    "section": "",
    "text": "convert_inventory(in_name, out_name=None)\nConvert a sphinx inventory file to json.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nin_name\n‘Union[str, soi.Inventory]’\nName of inventory file.\nrequired\n\n\nout_name\n\nOutput file name.\nNone"
  },
  {
    "objectID": "api/layout.Link.html",
    "href": "api/layout.Link.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.Link\nlayout.Link()\nA link to an object (e.g. a method that gets documented on a separate page).\nLink can be thought of as an alternative to quartodoc.layout.Doc. It doesn’t represent the documenting of an object, but a link to be made to some documentation."
  },
  {
    "objectID": "api/MdRenderer.summarize.html",
    "href": "api/MdRenderer.summarize.html",
    "title": "quartodoc",
    "section": "",
    "text": "MdRenderer.summarize\nMdRenderer.summarize(obj)\nProduce a summary table.\n\nsummarize(self, el: quartodoc.layout.Layout)\n\nsummarize(self, el: quartodoc.layout.Section)\n\nsummarize(self, el: quartodoc.layout.Page)\n\nsummarize(self, el: quartodoc.layout.MemberPage)\n\nsummarize(self, el: quartodoc.layout.Interlaced, *args, **kwargs)\n\nsummarize(self, el: quartodoc.layout.Doc, path: Optional[str] = None, shorten: bool = False)\n\nsummarize(self, el: quartodoc.layout.Link)\n\nsummarize(self, obj: Union[griffe.dataclasses.Object, griffe.dataclasses.Alias]) -> str\nTest"
  },
  {
    "objectID": "api/layout.DocClass.html",
    "href": "api/layout.DocClass.html",
    "title": "quartodoc",
    "section": "",
    "text": "layout.DocClass\nlayout.DocClass()\nDocument a python class."
  },
  {
    "objectID": "get-started/crossrefs.html",
    "href": "get-started/crossrefs.html",
    "title": "Linking to pages",
    "section": "",
    "text": "You can use quarto’s markdown linking syntax to link to function docs, by using the path to the generated documentation file.\nHere are some examples:\n\n\n\ncode\nresult\n\n\n\n\n[get_object](/reference/get_object.qmd)\nget_object\n\n\n[link text](/reference/MdRenderer.qmd)\nlink text"
  },
  {
    "objectID": "get-started/crossrefs.html#linking-by-function-name",
    "href": "get-started/crossrefs.html#linking-by-function-name",
    "title": "Linking to pages",
    "section": "Linking by function name",
    "text": "Linking by function name\nUse quartodoc’s interlinking filter to link to functions using only their names:\n\n\n\ncode\nresult\n\n\n\n\n[](`quartodoc.get_object`)\nquartodoc.get_object\n\n\n\nNotice that the link above puts the function name in backticks, rather than using the path to its documentation: `quartodoc.get_object`.\nYou can also use this approach to link to other documentation sites. For example, including links to quartodoc, or https://docs.python.org/3 using function names.\nSee the interlinks documentation for set up and usage."
  },
  {
    "objectID": "get-started/crossrefs.html#the-see-also-section",
    "href": "get-started/crossrefs.html#the-see-also-section",
    "title": "Linking to pages",
    "section": "The “See Also” section",
    "text": "The “See Also” section\nA major goal of quartodoc is to automatically turn text in the “See Also” section of docstrings into links.\nSee this issue for more details on parsing See Also sections, and this issue on turning type annotations into links."
  },
  {
    "objectID": "get-started/crossrefs.html#type-annotations-in-docstrings",
    "href": "get-started/crossrefs.html#type-annotations-in-docstrings",
    "title": "Linking to pages",
    "section": "Type annotations in docstrings",
    "text": "Type annotations in docstrings\nThis is planned, but currently unimplemented. See this issue on turning type annotations into links."
  },
  {
    "objectID": "get-started/overview.html",
    "href": "get-started/overview.html",
    "title": "Overview",
    "section": "",
    "text": "quartodoc lets you quickly generate Python package API reference documentation using Markdown and Quarto. quartodoc is designed as an alternative to Sphinx.\nCheck out the below screencast for a walkthrough of creating a documentation site, or read on for instructions."
  },
  {
    "objectID": "get-started/overview.html#installation",
    "href": "get-started/overview.html#installation",
    "title": "Overview",
    "section": "Installation",
    "text": "Installation\npython -m pip install quartodoc\nor from GitHub\npython -m pip install git+https://github.com/machow/quartodoc.git\n\n\n\n\n\n\nInstall Quarto\n\n\n\nIf you haven’t already, you’ll need to install Quarto before you can use quartodoc."
  },
  {
    "objectID": "get-started/overview.html#basic-use",
    "href": "get-started/overview.html#basic-use",
    "title": "Overview",
    "section": "Basic use",
    "text": "Basic use\nGetting started with quartodoc takes two steps: configuring quartodoc, then generating documentation pages for your library.\nYou can configure quartodoc alongside the rest of your Quarto site in the _quarto.yml file you are already using for Quarto. To configure quartodoc, you need to add a quartodoc section to the top level your _quarto.yml file. Below is a minimal example of a configuration that documents the quartodoc package:\nproject:\n  type: website\n\n# tell quarto to read the generated sidebar\nmetadata-files:\n  - _sidebar.yml\n\n\nquartodoc:\n  # the name used to import the package you want to create reference docs for\n  package: quartodoc\n\n  # write sidebar data to this file\n  sidebar: _sidebar.yml\n\n  sections:\n    - title: Some functions\n      desc: Functions to inspect docstrings.\n      contents:\n        # the functions being documented in the package.\n        # you can refer to anything: class methods, modules, etc..\n        - get_object\n        - preview\nNow that you have configured quartodoc, you can generate the reference API docs with the following command:\nquartodoc build\nThis will create a reference/ directory with an index.qmd and documentation pages for listed functions, like get_object and preview.\nFinally, preview your website with quarto:\nquarto preview"
  },
  {
    "objectID": "get-started/overview.html#rebuilding-site",
    "href": "get-started/overview.html#rebuilding-site",
    "title": "Overview",
    "section": "Rebuilding site",
    "text": "Rebuilding site\nYou can preview your quartodoc site using the following commands:\nFirst, watch for changes to the library you are documenting so that your docs will automatically re-generate:\nquartodoc build --watch\nSecond, preview your site:\nquarto preview"
  },
  {
    "objectID": "get-started/overview.html#looking-up-objects",
    "href": "get-started/overview.html#looking-up-objects",
    "title": "Overview",
    "section": "Looking up objects",
    "text": "Looking up objects\nGenerating API reference docs for Python objects involves two pieces of configuration:\n\nthe package name.\na list of objects for content.\n\nquartodoc can look up a wide variety of objects, including functions, modules, classes, attributes, and methods:\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: Some section\n      desc: \"\"\n      contents:\n        - get_object        # function: quartodoc.get_object\n        - ast.preview       # submodule func: quartodoc.ast.preview\n        - MdRenderer        # class: quartodoc.MdRenderer\n        - MdRenderer.render # method: quartodoc.MDRenderer.render\n        - renderers         # module: quartodoc.renderers\nThe functions listed in contents are assumed to be imported from the package."
  },
  {
    "objectID": "get-started/overview.html#learning-more",
    "href": "get-started/overview.html#learning-more",
    "title": "Overview",
    "section": "Learning more",
    "text": "Learning more\nGo to the next page to learn how to configure quartodoc sites, or check out these handy pages:\n\nExamples page: sites using quartodoc.\nTutorials page: screencasts of building a quartodoc site.\nDocstring issues and examples: common issues when formatting docstrings.\nProgramming, the big picture: the nitty gritty of how quartodoc works, and how to extend it."
  },
  {
    "objectID": "get-started/basic-docs.html",
    "href": "get-started/basic-docs.html",
    "title": "Configuring site",
    "section": "",
    "text": "quartodoc is configured by adding a quartodoc section to your _quarto.yml:\nquartodoc:\n  style: pkgdown\n  dir: reference\n  package: quartodoc\n  sections:\n    - title: Some functions\n      desc: Functions to inspect docstrings.\n      contents:\n        - get_object\n        - preview\n\n\nThe quartodoc section takes a style field, specifying which quartodoc.Builder to use (currently “pkgdown” or “single-page”; see Examples).\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package.\nrequired\n\n\nsections\n‘list[Any]’\nA list of sections, with items to document.\ntuple()\n\n\nversion\n‘str | None’\nThe package version. By default this attempts to look up the current package version (TODO).\nNone\n\n\ndir\nstr\nName of API directory.\n'reference'\n\n\ntitle\nstr\nTitle of the API index page.\n'Function reference'\n\n\nrenderer\n‘dict | Renderer | str’\nThe renderer used to convert docstrings (e.g. to markdown).\n'markdown'\n\n\noptions\n‘dict | None’\nDefault options to set for all pieces of content (e.g. include_attributes).\nNone\n\n\nout_index\nstr\nThe output path of the index file, used to list all API functions.\nNone\n\n\nsidebar\n‘str | None’\nThe output path for a sidebar yaml config (by default no config generated).\nNone\n\n\nrewrite_all_pages\n\nWhether to rewrite all rendered doc pages, or only those with changes.\nFalse\n\n\nsource_dir\n‘str | None’\nA directory where source files to be documented live. This is only necessary if you are not documenting a package, but collection of scripts. Use a “.” to refer to the current directory.\nNone\n\n\ndynamic\nbool | None\nWhether to dynamically load all python objects. By default, objects are loaded using static analysis.\nNone\n\n\nrender_interlinks\nbool\nWhether to render interlinks syntax inside documented objects. Note that the interlinks filter is required to generate the links in quarto.\nFalse\n\n\nparser\n\nDocstring parser to use. This correspond to different docstring styles, and can be one of “google”, “sphinx”, and “numpy”. Defaults to “numpy”.\n'numpy'\n\n\n\n\n\n\nThe sections field defines which functions to document.\nIt commonly requires three pieces of configuration:\n\ntitle: a title for the section\ndesc: a description for the section\ncontents: a list of functions to document\n\nYou can also replace title with subtitle to create a sub-section."
  },
  {
    "objectID": "get-started/architecture.html",
    "href": "get-started/architecture.html",
    "title": "Architecture",
    "section": "",
    "text": "classDiagram\n\n    class BuilderConfig {\n        style: str\n        package: str\n        version: str = None\n        dir: str = \"Reference\"\n        title: str = \"Function reference\"       \n        sections: list[SectionConfig]\n        out_inventory: str = \"objects.json\"\n        out_inder: str = \"index.qmd\"        \n        renderer: Renderer\n    }\n\n    class SectionConfig {\n        title: str\n        desc: str\n        //\n        // list of api functions\n        contents: list[str]\n    }\n\n    \n    class Introspect {\n        // functions for analyzing python objects\n        // and docstrings\n        get_object(module, object_name) -> griffe object\n\n    }\n\n    class Inventory {\n        // functions to work with sphinx inventories,\n        // which are used for cross-references\n        convert_inventory(in_name, out_name)\n        create_inventory(project, version, items, ...)\n\n    }\n    class Renderer {\n        style: str\n        header_level: int = 2\n        show_signature: bool = True\n        hook_pre: Callable = None\n        render(el: griffe object)\n    }\n\n    class Builder {\n        // Includes all BuilderConfig properties\n        ...BuilderConfig\n\n        //\n        // via create_* methods\n        items: dict[str, griffe object]\n        inventory: sphobjinv.Inventory\n\n\n        build()\n        create_items()\n        create_inventory()\n        fetch_object_uri()\n        fetch_object_dispname()\n        render_index()\n        write_doc_pages()\n        from_config() -> Builder\n    }\n\n    class BuilderPkgdown {\n        // write R pkgdown style docs\n        style: \"pkgdown\"\n        render_index()\n        fetch_object_uri()\n        fetch_object_dispname()\n    }\n    \n    class BuilderSinglePage {\n        // writes one big page of docs\n        style: \"single-page\"\n        render_index()\n        fetch_object_uri()\n        write_doc_pages()\n    }\n\n    class MdRenderer {\n        render()\n    }\n\n\n    Builder <|-- BuilderPkgdown\n    Builder <|-- BuilderSinglePage\n    BuilderConfig --> SectionConfig\n    BuilderConfig <-- Builder: from_config\n    Introspect <-- Builder: create_items    \n    Inventory <-- Builder: create_inventory(self.package, ..., self.items, self.fetch_*)\n    Renderer <-- Builder\n    Renderer <|-- MdRenderer"
  },
  {
    "objectID": "get-started/basic-content.html",
    "href": "get-started/basic-content.html",
    "title": "Configuring content",
    "section": "",
    "text": "Individual content entries (e.g. a function to be documented) can be customized. For example, if you are documenting a Python class, you may want to include or exclude documentation on specific methods on that class.\nSpecify content options by setting name: <content name> followed by any additional options.\nFor example, below is a single content element, MdRenderer, without additional options.\nInstead of documenting the entire MdRenderer class, we can only document the MdRenderer.render method by setting name: MdRenderer followed by the members option:\nIn the following sections, we’ll discuss different options for configuring content."
  },
  {
    "objectID": "get-started/basic-content.html#looking-up-objects",
    "href": "get-started/basic-content.html#looking-up-objects",
    "title": "Configuring content",
    "section": "Looking up objects",
    "text": "Looking up objects\nFinding Python objects to document involves two pieces of configuration:\n\nthe package name.\na list of objects for content.\n\nquartodoc can look up a wide variety of objects, including functions, modules, classes, attributes, and methods:\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: Some section\n      desc: \"\"\n      contents:\n        - get_object        # function: quartodoc.get_object\n        - ast.preview       # submodule func: quartodoc.ast.preview\n        - MdRenderer        # class: quartodoc.MdRenderer\n        - MdRenderer.render # method: quartodoc.MDRenderer.render\n        - renderers         # module: quartodoc.renderers\nThe functions listed in contents are those that are available for import from the package (quartodoc in this instance)."
  },
  {
    "objectID": "get-started/basic-content.html#module-and-class-members",
    "href": "get-started/basic-content.html#module-and-class-members",
    "title": "Configuring content",
    "section": "Module and class members",
    "text": "Module and class members\nDocumentation for classes and modules can automatically include their members (e.g. class methods and attributes or everything defined inside a module, respectively).\nBy default, all attributes and functions (including methods on a class) are presented in the embedded style, which means their documentation is located inside their respective module’s or class’s documentation.\nThere are four styles for presenting child members:\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nembedded\n\nEmbed documentation inside the parent object’s documentation.\n\n\nflat\n\nInclude documentation after the parent object’s documentation.\n\n\nseparate\n\nPut documentation for members on their own, separate pages.\n\n\nlinked\n\nInclude only a table of links to members (which may not be documented).\n\n\n\nYou can specify a style for displaying members by setting the children option in the config:\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: Some section\n      desc: \"\"\n      contents:\n\n        # set the children option, so that methods get documented\n        # on separate pages. MdRenderer's docs will include a summary\n        # table that links to each page.\n        - name: MdRenderer\n          children: separate"
  },
  {
    "objectID": "get-started/basic-content.html#setting-default-options",
    "href": "get-started/basic-content.html#setting-default-options",
    "title": "Configuring content",
    "section": "Setting default options",
    "text": "Setting default options\nThe section above showed how you can set options like members: (which is a list of the items you want to show) and children: (the style for presenting members) on content.\nHowever, you may desire to set the same options across multiple pieces of content. In this case, you can set default options for a section that applies to all content in that section. You can use the options: field to accomplish this.\nFor example, the config below shows how to document multiple classes without any child members. On the left, you can see the config without setting the default option, and on the right, you can see the config with the default option set.\n\n\nManual\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: \"Some section\"\n\n      # options set manually ---\n      contents:\n        - name: MdRenderer\n          members: []\n        - name: Builder\n          members: []\n\nWith options\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: \"Some section\"\n\n      # default options ---\n      options:\n        members: []\n      \n      contents:\n        - MdRenderer\n        - Builder\n\n\nBy setting members: [] in the options block, we are telling quartodoc to not include any members for each piece of content.\n\nReusing options\nOptions can be given a name and re-used in multiple sections:\n- title: Some section\n  options: &no-members\n    members: []\n  content:\n    - ThingA\n    - ThingB\n- title: Another section\n  options: *no-members\n  content:\n    - ThingC\nThe code above uses &no-members to name the options in the first section “no-members”, then *no-members to reference it in the second section. The & and * are called an anchor and alias, respectively, in YAML.\n\n\nWhere to put options\nYou can specify options in either the top-level config, or individual Sections.\nquartodoc:\n  package: quartodoc\n\n  # set options on the top-level config.\n  # this will apply to all pieces of content.\n  options:\n    include_attributes: false\n  sections:\n    - contents:\n        - MdRenderer\n\n      # set options in an individual section.\n      # in thise case, it resets include_attributes back\n      # to defaulting as true\n      options:\n        include_attributes: true"
  },
  {
    "objectID": "get-started/basic-content.html#specifying-package-path",
    "href": "get-started/basic-content.html#specifying-package-path",
    "title": "Configuring content",
    "section": "Specifying package path",
    "text": "Specifying package path\nDifferent levels of configuration let you set the package option. This controls the package path that quartodoc will try to import control content from.\nThe example below shows three different places it can be set: top-level site config, section config, or in a page element.\n# (1) package set on top-level site config\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: \"\"\n      desc: \"\"\n      contents:\n        - get_object         # quartodoc.get_object\n    \n    # (2) package set on a section\n    - title: \"\"\n      desc: \"\"\n      package: quartodoc.ast\n      contents:\n        - preview            # quartodoc.ast.preview\n\n        # (3) package set on a page\n        - kind: page\n          package: pandas\n          contents:\n            - DataFrame     # pandas.DataFrame\n        \n        # (4) package set on individual content entry\n        - package: pandas\n          name: Series\nUse package: null to unset the package option. This enables you to specify objects using their full name.\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: \"\"\n      desc: \"\"\n      package: null\n      contents:\n        - quartodoc.get_object"
  },
  {
    "objectID": "get-started/basic-content.html#dynamic-lookup",
    "href": "get-started/basic-content.html#dynamic-lookup",
    "title": "Configuring content",
    "section": "Dynamic lookup",
    "text": "Dynamic lookup\nBy default, quartodoc uses static analysis to look up objects. This means it gets information about your docstring without actually running your package’s code.\nThis usually works well, but may get the docstring wrong for those created in an extremely dynamic way (e.g. you manually set the __doc__ attribute on an object).\nIn this case, you can set the dynamic option on a piece of content.\ncontents:\n  - name: get_object\n    dynamic: true"
  },
  {
    "objectID": "get-started/basic-content.html#reference-page-sub-sections",
    "href": "get-started/basic-content.html#reference-page-sub-sections",
    "title": "Configuring content",
    "section": "Reference page sub-sections",
    "text": "Reference page sub-sections\nquartodoc supports two levels of grouping on the reference page. Use the subtitle: option to add an additional level of grouping.\nFor example, the code below creates an API reference page with one top-level section (“Some section”), with two sub-sections inside it.\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: Some section\n\n    - subtitle: Stuff A\n      desc: This is subsection A\n      contents:\n        - MdRenderer\n\n    - subtitle: Stuff B\n      desc: This is subsection B\n      contents:\n        - get_object"
  },
  {
    "objectID": "get-started/basic-content.html#grouping-on-a-page",
    "href": "get-started/basic-content.html#grouping-on-a-page",
    "title": "Configuring content",
    "section": "Grouping on a page",
    "text": "Grouping on a page\nBy default, content in each section gets included in the same index table, with each piece of content documented on its own page.\nFor example, consider the config below.\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: Cool functions\n      desc: \"\"\n      contents:\n        - get_object\n        - name: MdRenderer\n          members: [\"render\"]\nBoth get_object and MdRenderer will be:\n\nsummarized and linked to in the “Cool functions” section of the index.\ndocumented on their own, separate pages.\n\n\nPage layout element\nUse a custom page element to group object documentation on the same page.\nCustom page elements are specified by including a kind: <element name> field.\n\n\nSeparate\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: Cool functions\n      desc: \"\"\n\n      # normal contents setup ----\n      contents:\n        - get_object\n        - name: MdRenderer\n          members: [\"render\"]\n\nGrouped on same page\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: Cool functions\n      desc: \"\"\n\n      # contents with a page grouping ----\n      contents:\n        - kind: page\n          path: some_funcs\n          contents:\n            - get_object\n            - name: MdRenderer\n              members: [\"render\"]\n\n\nNote these three important pieces of the page entry:\n\nkind: page - indicates that we are creating a page\npath: - specifies what the name of the page will be in the generated docs. For example, path: some_funcs in the config above produces a file called some_funcs.qmd in the API reference folder.\ncontents: - lists out the contents of the page."
  },
  {
    "objectID": "get-started/basic-content.html#all-content-options",
    "href": "get-started/basic-content.html#all-content-options",
    "title": "Configuring content",
    "section": "All content options",
    "text": "All content options\nBelow is a summary of all the options that can be applied to individual content entries.\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nname\nstr\nName of the object. This should be the path needed to import it.\n\n\nsignature_name\n\nStyle of name to use in the signature. Can be “relative”, “full”, or “short”. Relative is whatever was used as the name argument, full is the fully qualified path the object, and short is the name of the object (i.e. no periods).\n\n\nmembers\n\nA list of members, such as attributes or methods on a class, to document.\n\n\ninclude_private\n\nWhether to include members starting with “_”\n\n\ninclude_imports\n\nWhether to include members that were imported from somewhere else.\n\n\ninclude_empty\n\nWhether to include members with no docstring.\n\n\ninclude_inherited\n\nWhether to include members inherited from a parent class.\n\n\ninclude_attributes\n\nWhether to include attributes.\n\n\ninclude_classes\n\nWhether to include classes.\n\n\ninclude_functions\n\nWhether to include functions.\n\n\ninclude\n\n(Not implemented). A list of members to include.\n\n\nexclude\n\n(Not implemented). A list of members to exclude.\n\n\ndynamic\n\nWhether to dynamically load docstring. By default docstrings are loaded using static analysis. dynamic may be a string pointing to another object, to return an alias for that object.\n\n\nchildren\n\nStyle for presenting members. Either separate, embedded, or flat.\n\n\npackage\n\nIf specified, object lookup will be relative to this path.\n\n\nmember_options\n\nOptions to apply to members. These can include any of the options above."
  },
  {
    "objectID": "get-started/extending.html",
    "href": "get-started/extending.html",
    "title": "More customization",
    "section": "",
    "text": "This page details 3 common aspects of quartodoc you can extend:"
  },
  {
    "objectID": "get-started/extending.html#using-a-custom-index-page",
    "href": "get-started/extending.html#using-a-custom-index-page",
    "title": "More customization",
    "section": "Using a custom index page",
    "text": "Using a custom index page\nUse a custom index page to add content before or after the automatically generated API index.\nYou can do this by setting quartodoc’s out_index to be something other than index.qmd, and then including it in a custom index.qmd file.\nFirst, set out_index in your _quarto.yml:\nwebsite:\n  navbar:\n    left:\n      - file: reference/index.qmd\n        text: Reference\n\nquartodoc:\n  dir: reference\n  out_index: reference/_api_index.qmd\nThen, create the file reference/index.qmd to have the form:\n---\n---\n\nSome custom content.\n\n\n{{< include /reference/_api_index.qmd >}}\n\n\nMore content stuff.\nNotice that the shortcode {{< include … >}} is used to insert the index file generated by quartodoc (_api_index.qmd)."
  },
  {
    "objectID": "get-started/extending.html#using-a-custom-renderer",
    "href": "get-started/extending.html#using-a-custom-renderer",
    "title": "More customization",
    "section": "Using a custom Renderer",
    "text": "Using a custom Renderer\nUse a custom renderer to add custom content after a renderered docstring, or to change the rendering process in general.\nYou can do this by creating a custom file for your renderer in your docs folder, like _renderer.py, and then referencing it in your _quarto.yml.\nquartodoc:\n  renderer:\n    style: _renderer.py\nSee the Rendering docstrings page for instructions on creating a custom renderer, and the quartodoc.MdRenderer docs for more information."
  },
  {
    "objectID": "get-started/extending.html#using-a-custom-builder",
    "href": "get-started/extending.html#using-a-custom-builder",
    "title": "More customization",
    "section": "Using a custom Builder",
    "text": "Using a custom Builder\nSince the Builder controls the full quartodoc build process, using a custom builder provides total flexibility. This option currently isn’t available, but would be easy to enable.\nPlease leave a note on this issue if you need to use a custom builder."
  },
  {
    "objectID": "get-started/dev-renderers.html",
    "href": "get-started/dev-renderers.html",
    "title": "Rendering docstrings",
    "section": "",
    "text": "The previous section covered how to read and preview parsed docstrings. In this section, we’ll look at how to render a parsed docstring into a format that can be used in documentation, like markdown or HTML."
  },
  {
    "objectID": "get-started/dev-renderers.html#setting-up-problem",
    "href": "get-started/dev-renderers.html#setting-up-problem",
    "title": "Rendering docstrings",
    "section": "Setting up problem",
    "text": "Setting up problem\nSuppose that we wanted to take a function like get_object() and render a summary, with:\n\nThe number of parameters it takes.\nThe number of sections in its parsed docstring.\n\nFor get_object() it might look like the following:\n## get_object\nN PARAMETERS: 3\nSECTIONS: A docstring with 4 pieces"
  },
  {
    "objectID": "get-started/dev-renderers.html#inspecting-a-function",
    "href": "get-started/dev-renderers.html#inspecting-a-function",
    "title": "Rendering docstrings",
    "section": "Inspecting a function",
    "text": "Inspecting a function\nAs covered in the previous section, we can preview information about get_object().\n\nfrom quartodoc import get_object, preview\n\nf_obj = get_object(\"quartodoc\", \"get_object\")\n\npreview(f_obj, max_depth=3)\n\n█─Alias\n├─name = 'get_object'\n├─annotation = █─Expression\n│              ├─0 = Name(source='dc', full='griffe.dataclasses')\n│              ├─1 = '.'\n│              └─2 = Name(source='Object', full='griffe.dataclasses.Obj ...\n├─parameters = █─Parameters\n│              ├─0 = █─Parameter\n│              │     ├─annotation = Name(source='str', full='str')\n│              │     ├─kind = <ParameterKind.positional_or_keyword: 'positional  ...\n│              │     ├─name = 'path'\n│              │     └─default = None\n│              ├─1 = █─Parameter\n│              │     ├─annotation = \"'str | None'\"\n│              │     ├─kind = <ParameterKind.positional_or_keyword: 'positional  ...\n│              │     ├─name = 'object_name'\n│              │     └─default = 'None'\n│              ├─2 = █─Parameter\n│              │     ├─annotation = Name(source='str', full='str')\n│              │     ├─kind = <ParameterKind.positional_or_keyword: 'positional  ...\n│              │     ├─name = 'parser'\n│              │     └─default = \"'numpy'\"\n│              ├─3 = █─Parameter\n│              │     ├─annotation = None\n│              │     ├─kind = <ParameterKind.positional_or_keyword: 'positional  ...\n│              │     ├─name = 'load_aliases'\n│              │     └─default = 'True'\n│              ├─4 = █─Parameter\n│              │     ├─annotation = None\n│              │     ├─kind = <ParameterKind.positional_or_keyword: 'positional  ...\n│              │     ├─name = 'dynamic'\n│              │     └─default = 'False'\n│              └─5 = █─Parameter\n│                    ├─annotation = █─Expression ...\n│                    ├─kind = <ParameterKind.positional_or_keyword: 'positional  ...\n│                    ├─name = 'loader'\n│                    └─default = 'None'\n└─docstring = █─Docstring\n              ├─parser = <Parser.numpy: 'numpy'>\n              └─parsed = █─list\n                         ├─0 = █─DocstringSectionText ...\n                         ├─1 = █─DocstringSectionParameters ...\n                         ├─2 = █─DocstringSectionSeeAlso ...\n                         ├─3 = █─DocstringSectionExamples ...\n                         └─4 = █─DocstringSectionReturns ...\n\n\nNote the following pieces:\n\npreview() takes a max_depth argument, that limits how much information it shows.\nget_object() takes 3 parameters.\nget_object() has a docstring with 4 sections.\n\nImportantly, the nodes (█) in the tree mention the name class of the python objects being previewed (e.g. Alias, Expression, Parameters). We’ll need these to specify how to render objects of each class."
  },
  {
    "objectID": "get-started/dev-renderers.html#generic-dispatch",
    "href": "get-started/dev-renderers.html#generic-dispatch",
    "title": "Rendering docstrings",
    "section": "Generic dispatch",
    "text": "Generic dispatch\nGeneric dispatch is the main programming technique used by quartodoc renderers. It let’s you define how a function (like render()) should operate on different types of objects.\n\nfrom plum import dispatch\n\nimport griffe.dataclasses as dc\nimport griffe.docstrings.dataclasses as ds\n\n\n@dispatch\ndef render(el: object):\n    print(f\"Default rendering: {type(el)}\")\n\n@dispatch\ndef render(el: dc.Alias):\n    print(\"Alias rendering\")\n    render(el.parameters)\n\n@dispatch\ndef render(el: list):\n    print(\"List rendering\")\n    [render(entry) for entry in el]\n\n\nrender(f_obj)\n\nAlias rendering\nDefault rendering: <class 'griffe.dataclasses.Parameters'>"
  },
  {
    "objectID": "get-started/dev-renderers.html#defining-a-renderer",
    "href": "get-started/dev-renderers.html#defining-a-renderer",
    "title": "Rendering docstrings",
    "section": "Defining a Renderer",
    "text": "Defining a Renderer\nquartodoc uses tree visitors to render parsed docstrings to formats like markdown and HTML. Tree visitors define how each type of object in the parse tree should be handled.\n\nimport griffe.dataclasses as dc\nimport griffe.docstrings.dataclasses as ds\n\nfrom quartodoc import get_object\nfrom plum import dispatch\nfrom typing import Union\n\n\nclass SomeRenderer:\n    def __init__(self, header_level: int = 1):\n        self.header_level = header_level\n\n    @dispatch\n    def render(self, el):\n        raise NotImplementedError(f\"Unsupported type: {type(el)}\")\n\n    @dispatch\n    def render(self, el: Union[dc.Alias, dc.Object]):\n        header = \"#\" * self.header_level\n        str_header = f\"{header} {el.name}\"\n        str_params = f\"N PARAMETERS: {len(el.parameters)}\"\n        str_sections = \"SECTIONS: \" + self.render(el.docstring)\n        \n        # return something pretty\n        return \"\\n\".join([str_header, str_params, str_sections])\n\n    @dispatch\n    def render(self, el: dc.Docstring):\n        return f\"A docstring with {len(el.parsed)} pieces\"\n\n\nf_obj = get_object(\"quartodoc\", \"get_object\")\n\nprint(SomeRenderer(header_level=2).render(f_obj))\n\n## get_object\nN PARAMETERS: 6\nSECTIONS: A docstring with 5 pieces\n\n\nNote 3 big pieces:\n\nGeneric dispatch: The plum dispatch function decorates each render method. The type annotations specify the types of data each version of render should dispatch on.\nDefault behavior: The first render method ensures a NotImplementedError is raised by default.\nTree walking: render methods often call render again on sub elements."
  },
  {
    "objectID": "get-started/dev-renderers.html#completing-the-renderer",
    "href": "get-started/dev-renderers.html#completing-the-renderer",
    "title": "Rendering docstrings",
    "section": "Completing the Renderer",
    "text": "Completing the Renderer\nWhile the above example showed a simple example with a .render method, a complete renderer will often do two more things:\n\nSubclass an existing renderer.\nAlso override other methods like .summarize()\n\n\nfrom quartodoc import MdRenderer\n\nclass NewRenderer(MdRenderer):\n    style = \"new_renderer\"\n\n    @dispatch\n    def render(self, el):\n        print(\"calling parent method for render\")\n        return super().render(el)\n    \n    @dispatch\n    def summarize(self, el):\n        print(\"calling parent method for summarize\")\n        return super().summarize(el)\n\nFor a list of methods, see the MdRenderer docs."
  },
  {
    "objectID": "get-started/dev-prepare.html",
    "href": "get-started/dev-prepare.html",
    "title": "Components: Auto, blueprint, collect",
    "section": "",
    "text": "from quartodoc import collect, preview\nfrom quartodoc import MdRenderer\nimport yaml"
  },
  {
    "objectID": "get-started/dev-prepare.html#blueprint-parse-metadata-from-objects",
    "href": "get-started/dev-prepare.html#blueprint-parse-metadata-from-objects",
    "title": "Components: Auto, blueprint, collect",
    "section": "blueprint: Parse Metadata From Objects",
    "text": "blueprint: Parse Metadata From Objects\nblueprint parses all of the metadata about the python object and stores it in a hierarchal tree structure that is convenient for a renderer to transform into a renderable format like HTML or Markdown. For example, here is the blueprint for the MdRenderer class:\n\nfrom quartodoc import blueprint\ndoc = blueprint(auto)\npreview(doc, max_depth=2)\n\n█─DocClass\n├─name = 'quartodoc.MdRenderer'\n├─obj = █─Alias\n│       ├─name = 'MdRenderer'\n│       ├─canonical_path = 'quartodoc.renderers.md_renderer.MdRenderer'\n│       ├─classes = █─dict ...\n│       ├─parameters = █─Parameters ...\n│       ├─members = █─dict ...\n│       ├─functions = █─dict ...\n│       └─docstring = █─Docstring ...\n├─anchor = 'quartodoc.MdRenderer'\n├─members = █─list\n│           ├─0 = █─DocFunction ...\n│           └─1 = █─DocFunction ...\n└─flat = False\n\n\nTo give you a sense of this tree structure, we can look at the obj.docstring field of the above blueprint, which contains information about the Python docstring:\n\npreview(doc.obj.docstring, max_depth=2)\n\n█─Docstring\n├─parser = <Parser.numpy: 'numpy'>\n└─parsed = █─list\n           ├─0 = █─DocstringSectionText ...\n           ├─1 = █─DocstringSectionParameters ...\n           └─2 = █─DocstringSectionExamples ...\n\n\nWe can see from this output that the parser for the docstring is numpy, which means the docstring is expected to be in the numpy style.\nFurthermore, we can see from the tree structure that the DocstringSectionText is stored as the first element in a list under the parsed attribute:\n\npreview(doc.obj.docstring.parsed[0])\n\n█─DocstringSectionText\n├─kind = <DocstringSectionKind.text: 'text'>\n├─title = None\n└─value = 'Render docstrings to markdown.'\n\n\nDocstringSectionText stores the “text” field of a numpy style docstring, which is the first line of the docstring, which is otherwise known as the short summary. Furthermore, we can see from the output above that the actual text of this short summary is stored in the value attribute:\n\ndocstr_firstln_value = doc.obj.docstring.parsed[0].value\nprint(docstr_firstln_value)\n\nRender docstrings to markdown.\n\n\nWe can check the docstring of MdRenderer to see that this is indeed the first line of the docstring:\n\nfrom inspect import getdoc\ndocstr_firstln = getdoc(MdRenderer).splitlines()[0]\n\n# These are the same\nassert docstr_firstln == docstr_firstln_value\nprint(docstr_firstln)\n\nRender docstrings to markdown."
  },
  {
    "objectID": "get-started/dev-prepare.html#layout-sections",
    "href": "get-started/dev-prepare.html#layout-sections",
    "title": "Components: Auto, blueprint, collect",
    "section": "Layout & Sections",
    "text": "Layout & Sections\nThe Layout class stores how you wish to organize your documentation. For example, you may wish to organize your documentation into sections, where each section contains a title, description, and a list of objects to document. You can create a layout like this:\n\nimport yaml\nfrom quartodoc import Builder\n\ncfg = yaml.safe_load(\"\"\"\nquartodoc:\n  package: quartodoc\n  sections:\n    - title: \"Some section\"\n      desc: \"Some description\"\n      contents:\n        - name: MdRenderer\n    - title: \"Another section\"\n      desc: \"Another description\"\n      contents:\n        - Auto\n        - blueprint \n\"\"\")\n\nbuilder = Builder.from_quarto_config(cfg)\nauto_from_yml = builder.layout.sections[0].contents[0]\npreview(builder.layout, max_depth=3)\n\n█─Layout\n├─sections = █─list\n│            ├─0 = █─Section\n│            │     ├─title = 'Some section'\n│            │     ├─desc = 'Some description'\n│            │     └─contents = █─list ...\n│            └─1 = █─Section\n│                  ├─title = 'Another section'\n│                  ├─desc = 'Another description'\n│                  └─contents = █─list ...\n└─package = 'quartodoc'\n\n\nAs you can see, the Layout stores the sections, which are stored in the sections attribute. Each section contains a title, desc, and contents attribute and is stored in a Section class.\nThe contents attribute is a list of objects to document. In this case, the first section contains a single object, the MdRenderer class, while the second section contains two objects. You can read more about Section options here.\nIn addition to building a layout from a yaml file, you can also build a layout in Python by instantiating the Layout class like so:\n\nfrom quartodoc import Auto, layout\n\nauto = Auto(name = \"quartodoc.MdRenderer\", \n            signature_name = 'short')\n\nlay = layout.Layout(\n    sections = [\n      layout.Section(title = \"A section\", \n                      desc = \"A description\", \n                      contents = [auto])\n    ]\n)\n\nWe can view the layout by calling the preview function:\n\npreview(lay, \n        max_depth=8, \n        compact=True)\n\n█─Layout\n└─sections = \n  █─list\n  └─0 = \n    █─Section\n    ├─title = 'A section'\n    ├─desc = 'A description'\n    └─contents = \n      █─list\n      └─0 = \n        █─Auto\n        ├─signature_name = 'short'\n        └─name = 'quartodoc.MdRenderer'\n\n\nRecall that the blueprint function parses all of the metadata about the Python object. We can see how a blueprint adds additional data pertaining to MdRenderer, that wasn’t present in the layout above:\n\nbp_layout = blueprint(lay) \npreview(bp_layout, \n        max_depth=8, \n        compact=True)\n\n█─Layout\n└─sections = \n  █─list\n  └─0 = \n    █─Section\n    ├─title = 'A section'\n    ├─desc = 'A description'\n    └─contents = \n      █─list\n      └─0 = \n        █─Page\n        ├─path = 'quartodoc.MdRenderer'\n        └─contents = \n          █─list\n          └─0 = \n            █─DocClass\n            ├─name = 'quartodoc.MdRenderer'\n            ├─obj = \n            │ █─Alias\n            │ ├─name = 'MdRenderer'\n            │ ├─canonical_path = 'quartodoc.renderers.md_renderer.MdRenderer'\n            │ ├─classes = █─dict ...\n            │ ├─parameters = \n            │ │ █─Parameters ...\n            │ ├─members = \n            │ │ █─dict ...\n            │ ├─functions = \n            │ │ █─dict ...\n            │ └─docstring = \n            │   █─Docstring ...\n            ├─anchor = 'quartodoc.MdRenderer'\n            ├─signature_name = 'short'\n            ├─members = \n            │ █─list\n            │ ├─0 = \n            │ │ █─DocFunction ...\n            │ └─1 = \n            │   █─DocFunction ...\n            └─flat = False\n\n\n\nGrouping docs on a page\nThe Layout also calculates how to split your sections into pages based on the options you set in your yaml configuration. For example, if you set the children option to separate, then each object in a section will be placed on its own page.\nLet’s see the difference between the separate and embedded options by creating two Auto objects for the MdRenderer class, one with children set to separate and the other with children set to embedded:\n\nauto_sep = layout.Auto(name = \"quartodoc.MdRenderer\", \n                       children = \"separate\")\nauto_emb = layout.Auto(name = \"quartodoc.MdRenderer\", \n                       children = \"embedded\")\n\n\n\n\nbp_emb = blueprint(auto_emb)\npreview(bp_emb, \n        max_depth=2,\n        compact=True)\n\n█─DocClass\n├─name = 'quartodoc.MdRenderer'\n├─obj = \n│ █─Alias\n│ ├─name = 'MdRenderer'\n│ ├─canonical_path = 'quartodoc.renderers.md_renderer.MdRenderer'\n│ ├─classes = █─dict ...\n│ ├─parameters = \n│ │ █─Parameters ...\n│ ├─members = \n│ │ █─dict ...\n│ ├─functions = \n│ │ █─dict ...\n│ └─docstring = \n│   █─Docstring ...\n├─anchor = 'quartodoc.MdRenderer'\n├─members = \n│ █─list\n│ ├─0 = \n│ │ █─DocFunction ...\n│ └─1 = \n│   █─DocFunction ...\n└─flat = False\n\n\n\n\nbp_sep = blueprint(auto_sep)\npreview(bp_sep, \n        max_depth=2,\n        compact=True)\n\n█─DocClass\n├─name = 'quartodoc.MdRenderer'\n├─obj = \n│ █─Alias\n│ ├─name = 'MdRenderer'\n│ ├─canonical_path = 'quartodoc.renderers.md_renderer.MdRenderer'\n│ ├─classes = █─dict ...\n│ ├─parameters = \n│ │ █─Parameters ...\n│ ├─members = \n│ │ █─dict ...\n│ ├─functions = \n│ │ █─dict ...\n│ └─docstring = \n│   █─Docstring ...\n├─anchor = 'quartodoc.MdRenderer'\n├─members = \n│ █─list\n│ ├─0 = \n│ │ █─MemberPage ...\n│ └─1 = \n│   █─MemberPage ...\n└─flat = False"
  },
  {
    "objectID": "get-started/dev-prepare.html#collect-fetch-all-pages-and-items",
    "href": "get-started/dev-prepare.html#collect-fetch-all-pages-and-items",
    "title": "Components: Auto, blueprint, collect",
    "section": "Collect: fetch all pages and items",
    "text": "Collect: fetch all pages and items\n\nsome_page = layout.Page(path = \"some_doc_page\", contents = [doc])\npages, items = collect(some_page, \"reference\")\npages\n\n[Page(kind='page', path='some_doc_page', package=MISSING(), summary=None, flatten=False, contents=[DocClass(name='quartodoc.MdRenderer', obj=<Alias('MdRenderer', 'quartodoc.renderers.MdRenderer')>, anchor='quartodoc.MdRenderer', signature_name='relative', kind='class', members=[DocFunction(name='render', obj=<Alias('render', 'quartodoc.renderers.md_renderer.MdRenderer.render')>, anchor='quartodoc.MdRenderer.render', signature_name='relative', kind='function'), DocFunction(name='summarize', obj=<Alias('summarize', 'quartodoc.renderers.md_renderer.MdRenderer.summarize')>, anchor='quartodoc.MdRenderer.summarize', signature_name='relative', kind='function')], flat=False)])]"
  },
  {
    "objectID": "get-started/advanced-layouts.html#children-options",
    "href": "get-started/advanced-layouts.html#children-options",
    "title": "Advanced layouts",
    "section": "Children options",
    "text": "Children options"
  },
  {
    "objectID": "get-started/docstring-style.html",
    "href": "get-started/docstring-style.html",
    "title": "Docstring formats",
    "section": "",
    "text": "quartodoc prefers numpy style for docstrings, but can support other styles by configuring parser in your quartodoc site options of _quarto.yml:\nquartodoc:\n  parser: google\nCurrently, google, sphinx, and numpy are supported. Parsing is handled by the tool griffe.\n\nResources\nSee the numpydoc sections guide for more information and examples."
  },
  {
    "objectID": "get-started/docstring-examples.html",
    "href": "get-started/docstring-examples.html",
    "title": "Common issues and examples",
    "section": "",
    "text": "This page provides examples for commonly encountered situations (and some funky ones).\nSee the numpydoc sections guide for more information and examples."
  },
  {
    "objectID": "get-started/docstring-examples.html#examples-using-code-blocks",
    "href": "get-started/docstring-examples.html#examples-using-code-blocks",
    "title": "Common issues and examples",
    "section": "Examples: using code blocks",
    "text": "Examples: using code blocks\nOften, the Examples section of docstrings contain code examples.\nThe Examples section supports two formats for code examples:\n\ndoctest syntax - code starts with >>>.\nmarkdown syntax - surrounding code with three backticks (```)\nquarto syntax - similar to markdown syntax (e.g. ```{python}), but will execute code in the docs.\n\nBelow is an example including each.\n    Examples\n    --------\n    \n    doctest syntax:\n    \n    >>> 1 + 1\n    2\n    \n    markdown syntax:\n    \n    ```python\n    1 + 1\n    ```\n    \n    quarto syntax:\n    \n    ```{python}\n    1 + 1\n    ```\nNote that different syntaxes are handled differently:\n\ndoctest and markdown syntax: rendered without executing.\nquarto syntax: executed by quarto when you run commands like quarto render.\n\nSee the quarto documentation on code blocks for more detail."
  },
  {
    "objectID": "get-started/docstring-examples.html#examples-etc..-the-s-matters",
    "href": "get-started/docstring-examples.html#examples-etc..-the-s-matters",
    "title": "Common issues and examples",
    "section": "Examples, etc..: the “s” matters",
    "text": "Examples, etc..: the “s” matters\nThe numpydoc spec pluralizes section most names. If you leave off the “s”, then they may be misparsed.\nFor example, the docstring below erroneously has a “Return” section:\nReturn\n------\n\nsome_name: int\n    a description of the return result\nIn this case, the section won’t be parsed, but written directly into the doc page. This means that “Return” would show up as a level 2 header.\nHere is a list of pluralized section names:\n\nParameters\nReturns\nYields\nReceives\nOther Parameters\nRaises\nWarns\nWarnings\nNotes\nReferences\nExamples"
  },
  {
    "objectID": "get-started/docstring-examples.html#returns-using-type-annotation",
    "href": "get-started/docstring-examples.html#returns-using-type-annotation",
    "title": "Common issues and examples",
    "section": "Returns: using type annotation",
    "text": "Returns: using type annotation\nIn order to use the return type annotation of a function, use the following syntax.\nReturns\n--------\n:\n    Some description of result\nBelow is a full example.\n\ndef f() -> int:\n    \"\"\"Some func\n\n    Returns\n    -------\n    :\n        A number\n    \"\"\"\n\nSee the numpydoc Returns specification for more on the general form of the Returns section."
  },
  {
    "objectID": "get-started/docstring-examples.html#using-interlinks-in-docstrings",
    "href": "get-started/docstring-examples.html#using-interlinks-in-docstrings",
    "title": "Common issues and examples",
    "section": "Using interlinks in docstrings",
    "text": "Using interlinks in docstrings\nquartodoc supports linking to functions using the interlinks quarto filter (and linking in general using quarto link syntax).\nThe code below shows an interlink, along with a regular quarto link.\ndef f():\n    \"\"\"A function.\n\n    Interlinks filter:\n\n    See [](`quartodoc.get_object`)\n\n    Regular quarto link (to a page in your docs):\n\n    See the [reference](/reference/index.qmd) page.\n    \"\"\"\n\n\n\n\n\n\nNote\n\n\n\nLinking to functions documented outside your package must be configured in the interlinks filter."
  },
  {
    "objectID": "get-started/docstring-examples.html#how-do-i-document-a-class",
    "href": "get-started/docstring-examples.html#how-do-i-document-a-class",
    "title": "Common issues and examples",
    "section": "How do I document a class?",
    "text": "How do I document a class?\nSee this numpydoc page on documenting classes.\nBelow is a simple example of a class docstring.\nclass MyClass:\n    \"\"\"A great class.\n\n    Parameters\n    ----------\n    a:\n        Some parameter.\n\n    Attributes\n    ----------\n    x:\n        An integer\n    \"\"\"\n\n\n    x: int = 1\n\n\n    def __init__(self, a: str):\n        self.a = a\nNote these two important pieces:\n\nDocument your __init__ method parameters on the class docstring.\nYou can use an Attributes section in your docstring."
  },
  {
    "objectID": "get-started/dev-big-picture.html",
    "href": "get-started/dev-big-picture.html",
    "title": "The big picture: Builder",
    "section": "",
    "text": "While the “Basic Use” section covered how to configure and build a site with quartodoc, this section focuses on using quartodoc as a Python program.\nProgramming with quartodoc will help with debugging, tinkering, and extending things."
  },
  {
    "objectID": "get-started/dev-big-picture.html#overview",
    "href": "get-started/dev-big-picture.html#overview",
    "title": "The big picture: Builder",
    "section": "Overview",
    "text": "Overview\nWhen a user runs quartodoc build, they\n\nCreate a Builder object, with the quartodoc config loaded as a layout.Layout.\nUse blueprint to process the layout into a plan for building the website.\nUse collect to get pages to render, and info on where documented objects live.\n\nThis page will cover the basics of the Builder and this process."
  },
  {
    "objectID": "get-started/dev-big-picture.html#the-builder",
    "href": "get-started/dev-big-picture.html#the-builder",
    "title": "The big picture: Builder",
    "section": "The Builder",
    "text": "The Builder\nThe code below shows a Builder object being loaded from a _quarto.yml config (loaded as a Python dictionary).\n\nimport yaml\n\nfrom quartodoc import Builder, blueprint, collect, MdRenderer\n\ncfg = yaml.safe_load(\"\"\"\nquartodoc:\n  package: quartodoc\n  style: pkgdown\n  sections:\n    - title: \"Some section\"\n      desc: \"Some description\"\n      contents:\n        - name: MdRenderer\n          members: [\"render\", \"summarize\"]\n          children: separate\n\"\"\")\n\nbuilder = Builder.from_quarto_config(cfg)\nbuilder\n\n<quartodoc.autosummary.BuilderPkgdown at 0x7f3421e7c430>\n\n\nNote that .from_quarto_config used the style: field to decide which Builder to create (in this case, BuilderPkgdown).\nWe can view the config as a layout.Layout, by looking at the .layout attribute.\n\nbuilder.layout\n\nLayout(sections=[Section(kind='section', title='Some section', subtitle=None, desc='Some description', package=MISSING(), contents=[Auto(signature_name='relative', members=['render', 'summarize'], include_private=False, include_imports=False, include_empty=False, include_inherited=False, include_attributes=True, include_classes=True, include_functions=True, include=None, exclude=None, dynamic=None, children=<ChoicesChildren.separate: 'separate'>, package=MISSING(), member_options=None, kind='auto', name='MdRenderer')], options=None)], package='quartodoc', options=None)\n\n\nThis can be a bit difficult to read, so quartodoc implements a preview function, which spaces things out.\n\nfrom quartodoc import preview\npreview(builder.layout)\n\n█─Layout\n├─sections = █─list\n│            └─0 = █─Section\n│                  ├─title = 'Some section'\n│                  ├─desc = 'Some description'\n│                  └─contents = █─list\n│                               └─0 = █─Auto\n│                                     ├─members = █─list\n│                                     │           ├─0 = 'render'\n│                                     │           └─1 = 'summarize'\n│                                     ├─children = <ChoicesChildren.separate: 'separate'>\n│                                     └─name = 'MdRenderer'\n└─package = 'quartodoc'\n\n\nNotice the following:\n\npreview represents calls like Layout() with a box to the left, and then a pipe connecting it to each of its arguments.\nThe content entry MdRenderer is represented by an Auto class. This specifies a Python object to look up and document.\n\nWe can follow the path in the preview above, to pull out just this first piece of content containing MdRenderer:\n\ncontent = builder.layout.sections[0].contents[0]\npreview(content)\n\n█─Auto\n├─members = █─list\n│           ├─0 = 'render'\n│           └─1 = 'summarize'\n├─children = <ChoicesChildren.separate: 'separate'>\n└─name = 'MdRenderer'\n\n\nNext, we’ll look at blueprint(), which processes the layout, including transforming Auto objects (like the one representing the MdRenderer above) into more concrete instructions."
  },
  {
    "objectID": "get-started/dev-big-picture.html#from-config-to-blueprint",
    "href": "get-started/dev-big-picture.html#from-config-to-blueprint",
    "title": "The big picture: Builder",
    "section": "From config to blueprint",
    "text": "From config to blueprint\nThe code below shows how blueprint() transforms the Auto entry for MdRenderer.\n\nbp = blueprint(builder.layout)\nbp_contents = bp.sections[0].contents[0]\npreview(bp_contents, max_depth=3)\n\n█─Page\n├─path = 'MdRenderer'\n└─contents = █─list\n             └─0 = █─DocClass\n                   ├─name = 'MdRenderer'\n                   ├─obj = █─Alias ...\n                   ├─anchor = 'quartodoc.MdRenderer'\n                   ├─members = █─list ...\n                   └─flat = False\n\n\nNotice two key pieces:\n\nThe Auto element is now a layout.Page. The .path indicates that the documentation will be on a page called \"MdRenderer\".\nThe content of the page is a layout.DocClass. This element holds everything needed to render this doc, including the class signature and parsed docstring.\n\nImportantly, the .members attribute stores how to render the class methods we listed in our configuration yaml, .render() and .summarize():\n\npreview(bp_contents.contents[0].members, max_depth=2)\n\n█─list\n├─0 = █─MemberPage\n│     ├─path = 'quartodoc.MdRenderer.render'\n│     └─contents = █─list ...\n└─1 = █─MemberPage\n      ├─path = 'quartodoc.MdRenderer.summarize'\n      └─contents = █─list ...\n\n\nNote that they are also a instances of Page (MemberPage to be exact). Before to building the site, we need to collect() all the pages."
  },
  {
    "objectID": "get-started/dev-big-picture.html#collecting-pages-and-items",
    "href": "get-started/dev-big-picture.html#collecting-pages-and-items",
    "title": "The big picture: Builder",
    "section": "Collecting pages and items",
    "text": "Collecting pages and items\nThe collect function pulls out two important pieces of information:\n\npages - each page to be rendered.\nitems - information on where each documented object lives in the site, which is used for things like interlinks.\n\n\npages, items = collect(bp, builder.dir)\npreview(pages, max_depth=3)\n\n█─list\n├─0 = █─MemberPage\n│     ├─path = 'quartodoc.MdRenderer.render'\n│     └─contents = █─list\n│                  └─0 = █─DocFunction ...\n├─1 = █─MemberPage\n│     ├─path = 'quartodoc.MdRenderer.summarize'\n│     └─contents = █─list\n│                  └─0 = █─DocFunction ...\n└─2 = █─Page\n      ├─path = 'MdRenderer'\n      └─contents = █─list\n                   └─0 = █─DocClass ...\n\n\nThe code below shows a preview of the items.\n\npreview(items, max_depth=2)\n\n█─list\n├─0 = █─Item\n│     ├─name = 'quartodoc.MdRenderer.render'\n│     ├─obj = █─Alias ...\n│     └─uri = 'reference/quartodoc.MdRenderer.render.html#quarto ...\n├─1 = █─Item\n│     ├─name = 'quartodoc.renderers.md_renderer.MdRenderer.render ...\n│     ├─obj = █─Alias ...\n│     ├─uri = 'reference/quartodoc.MdRenderer.render.html#quarto ...\n│     └─dispname = 'quartodoc.MdRenderer.render'\n├─2 = █─Item\n│     ├─name = 'quartodoc.MdRenderer.summarize'\n│     ├─obj = █─Alias ...\n│     └─uri = 'reference/quartodoc.MdRenderer.summarize.html#qua ...\n├─3 = █─Item\n│     ├─name = 'quartodoc.renderers.md_renderer.MdRenderer.summar ...\n│     ├─obj = █─Alias ...\n│     ├─uri = 'reference/quartodoc.MdRenderer.summarize.html#qua ...\n│     └─dispname = 'quartodoc.MdRenderer.summarize'\n├─4 = █─Item\n│     ├─name = 'quartodoc.MdRenderer'\n│     ├─obj = █─Alias ...\n│     └─uri = 'reference/MdRenderer.html#quartodoc.MdRenderer'\n└─5 = █─Item\n      ├─name = 'quartodoc.renderers.md_renderer.MdRenderer'\n      ├─obj = █─Alias ...\n      ├─uri = 'reference/MdRenderer.html#quartodoc.MdRenderer'\n      └─dispname = 'quartodoc.MdRenderer'\n\n\nNotice that if you wanted to look up quartodoc.MdRenderer.render, the first item’s .uri attribute shows the URL for it, relative to wherever the doc site is hosted."
  },
  {
    "objectID": "get-started/dev-big-picture.html#rendering-and-writing",
    "href": "get-started/dev-big-picture.html#rendering-and-writing",
    "title": "The big picture: Builder",
    "section": "Rendering and writing",
    "text": "Rendering and writing\nA Builder instantiates a Renderer (like MdRenderer). Use the .renderer attribute to access it:\n\nbuilder.renderer\n\n<quartodoc.renderers.md_renderer.MdRenderer at 0x7f3421e716f0>\n\n\nThe render method of of the MdRenderer returns a markdown string that can be rendered by Quarto:\n\nprint(builder.renderer.render(pages[0]))\n\n# render { #quartodoc.MdRenderer.render }\n\n`MdRenderer.render(el)`\n\n\n\n\n\n\n\n\n\n\nCross References\n\n\n\nThe { #quartodoc.MdRenderer.render } in the output above is extended Quarto markdown that is a cross reference."
  },
  {
    "objectID": "get-started/dev-big-picture.html#writing-pages",
    "href": "get-started/dev-big-picture.html#writing-pages",
    "title": "The big picture: Builder",
    "section": "Writing pages",
    "text": "Writing pages\nThe builder has a number of methods it uses while materializing files that will be rendered by Quarto. The main method is .build(). See the Builder section of the API for a list of methods, or this giant build process diagram for a full breakdown."
  },
  {
    "objectID": "get-started/interlinks.html",
    "href": "get-started/interlinks.html",
    "title": "Interlinks filter",
    "section": "",
    "text": "The interlinks filter allows you to provide crossreferences within and between documentation. It consists of three pieces:"
  },
  {
    "objectID": "get-started/interlinks.html#installing",
    "href": "get-started/interlinks.html#installing",
    "title": "Interlinks filter",
    "section": "Installing",
    "text": "Installing\nUse the quarto add command to install the interlinks filter:\nquarto add machow/quartodoc\n\n\n\n\n\n\nNote\n\n\n\nThe code for the filter can be found in quartodoc’s _extension folder"
  },
  {
    "objectID": "get-started/interlinks.html#configuring-the-interlinks-filter",
    "href": "get-started/interlinks.html#configuring-the-interlinks-filter",
    "title": "Interlinks filter",
    "section": "Configuring the interlinks filter",
    "text": "Configuring the interlinks filter\nConfigure the filter in _quarto.yml or on specific pages, by adding these sections:\nfilters:\n  - interlinks\n\ninterlinks:\n  sources:\n    numpy:\n      url: https://numpy.org/doc/stable/\n    python:\n      url: https://docs.python.org/3/\nNotice 2 important pieces in this config:\n\nThe numpy and python fields indicate that we’re getting inventories for the library numpy, and python builtin libraries.\nThe url fields indicate where inventory files can be found.\n\nBy default, downloaded inventory files will be saved in the _inv folder of your documentation directory.\n\nExperimental fast option\nUse the experimental fast: true option to speed up the interlinks filter.\ninterlinks:\n  fast: true\n  sources:\nBy default inventory files are saved as JSON, but this option keeps them as text files, and attempts to parse them much faster.\n\n\n\n\n\n\nWarning\n\n\n\nBe sure to install the latest version of the interlinks filter, using quarto add machow/quartodoc.\n\n\n\n\nRendering interlinks in API docs\nquartodoc can convert type annotations in function signatures to interlinks.\nIn order to enable this behavior, set render_interlinks: true in the quartodoc config.\nquartodoc:\n  render_interlinks: true"
  },
  {
    "objectID": "get-started/interlinks.html#running-the-interlinks-filter",
    "href": "get-started/interlinks.html#running-the-interlinks-filter",
    "title": "Interlinks filter",
    "section": "Running the interlinks filter",
    "text": "Running the interlinks filter\nFirst, build the reference for your own site, which includes an objects.json inventory:\npython -m quartodoc build\nSecond, retrieve the inventory files for any other sources:\npython -m quartodoc interlinks\nFinally you should see the filter run when previewing your docs:\nquarto preview"
  },
  {
    "objectID": "get-started/interlinks.html#link-formats",
    "href": "get-started/interlinks.html#link-formats",
    "title": "Interlinks filter",
    "section": "Link formats",
    "text": "Link formats\n\n\n\nstyle\nlink text\nsyntax\noutput\n\n\n\n\nmanual\n\n[a link](../api/#get_object)\na link\n\n\nmd\ncustom\n[some explanation](`quartodoc.get_object`)\nsome explanation\n\n\nmd\ndefault\n[](`quartodoc.get_object`)\nquartodoc.get_object\n\n\nmd\nshortened\n[](`~quartodoc.get_object`)\nget_object"
  },
  {
    "objectID": "get-started/interlinks.html#link-filtering-syntax",
    "href": "get-started/interlinks.html#link-filtering-syntax",
    "title": "Interlinks filter",
    "section": "Link filtering syntax",
    "text": "Link filtering syntax\nSometimes multiple documentation sites use the same target (e.g. function) names. The inventory format includes multiple pieces of information that can be used to refer to a specific entry in the inventory:\n\ninventory_name\nrole: what kind of object is it? e.g. function, class.\ndomain: what kind of piece of documentation is it? For example, \"py\" indicates it is a python function, and \"c\" indicates it’s a C function. This lets sites document libraries that are implemented in multiple languages.\n\nFiltering by these pieces of information can be down using the following syntax:\n:external+inventory_name:domain:role:`target`\n:domain:role:`target`\n:role:`target`\n`target`\nNotice that this syntax allows you to go from more specific information (i.e. `target` on the right), to least specific information (role, then domain).\nIn practice, it’s often enough to specify the role of a function, like:\n\n:function:`quartodoc.get_object`\n:class:`quartodoc.MdRenderer`\n\n\nExample: python.org print\nFor example, python.org has two entries for the name print.\n\n\n\ndomain\nrole\nlink syntax\n\n\n\n\nstd\n2to3fixer\n[](:std:2to3fixer:`print`)\n\n\npy\nfunction\n[](:py:function:`print`)"
  },
  {
    "objectID": "get-started/interlinks.html#what-is-a-sphinx-inventory-file",
    "href": "get-started/interlinks.html#what-is-a-sphinx-inventory-file",
    "title": "Interlinks filter",
    "section": "What is a sphinx inventory file?",
    "text": "What is a sphinx inventory file?\nSphinx inventory files provide information about where the documentation for functions live on a website.\nMost sphinx sites name them object.inv:\n\nnumpy: https://numpy.org/doc/stable/objects.inv\npython: https://docs.python.org/3/objects.inv\n\nSee the sphobjinv docs for thorough details on these files, and how they’re used in sphinx."
  },
  {
    "objectID": "get-started/interlinks.html#more-information",
    "href": "get-started/interlinks.html#more-information",
    "title": "Interlinks filter",
    "section": "More information",
    "text": "More information\nUnder the hood, quarto doc generates sphinx inventories for an API e using create_inventory, and then dumps it to JSON using convert_inventory.\nFor an overview of the sphinx inventory format, see the sphobjinv docs.\nThe rough idea is that this plugin will behave similar to jupyterbook linking, which supports both some intersphinx syntax, but also markdown syntax."
  },
  {
    "objectID": "get-started/dev-docstrings.html",
    "href": "get-started/dev-docstrings.html",
    "title": "Inspecting docstrings",
    "section": "",
    "text": "quartodoc uses the library griffe to load and parse docstrings."
  },
  {
    "objectID": "get-started/dev-docstrings.html#docstring-structure",
    "href": "get-started/dev-docstrings.html#docstring-structure",
    "title": "Inspecting docstrings",
    "section": "Docstring structure",
    "text": "Docstring structure\nquartodoc currently expects docstrings to be in the numpydocstring format.\nDocstrings are loaded and parsed using griffe, which uses custom data classes to represent the structure of a program:\n\ngriffe.dataclasses - represent the structure of python objects.\ngriffe.docstrings.dataclasses - represent the structure of parsed docstrings."
  },
  {
    "objectID": "get-started/dev-docstrings.html#reading-docstrings",
    "href": "get-started/dev-docstrings.html#reading-docstrings",
    "title": "Inspecting docstrings",
    "section": "Reading docstrings",
    "text": "Reading docstrings\nUse the function get_object to read in a docstring from a module.\n\nfrom quartodoc import get_object, preview\n\nf_obj = get_object(\"quartodoc\", \"get_object\")\nf_obj\n\n<Alias('get_object', 'quartodoc.autosummary.get_object')>\n\n\nThe result above is a griffe object representing the function quartodoc.get_object, which has two important attributes:\n\n.name: the function’s name.\n.parameters: the function’s parameters.\n.docstring.value: the actual docstring\n.docstring.parsed: the docstring parsed into a tree of griffe objects\n\n\nFunction name\n\nf_obj.name\n\n'get_object'\n\n\n\n\nFunction parameters\n\nf_obj.parameters\n\n<griffe.dataclasses.Parameters at 0x7eff4cb30190>\n\n\n\n\nRaw docstring value\n\nprint(f_obj.docstring.value)\n\nFetch a griffe object.\n\nParameters\n----------\npath: str\n    An import path to the object. This should have the form `path.to.module:object`.\n    For example, `quartodoc:get_object` or `quartodoc:MdRenderer.render`.\nobject_name: str\n    (Deprecated). A function name.\nparser: str\n    A docstring parser to use.\nload_aliases: bool\n    For aliases that were imported from other modules, should we load that module?\ndynamic: bool\n    Whether to dynamically import object. Useful if docstring is not hard-coded,\n    but was set on object by running python code.\n\nSee Also\n--------\npreview: print a user-friendly preview of a griffe object.\n\nExamples\n--------\n\n>>> get_function(\"quartodoc\", \"get_function\")\n<Function('get_function', ...\n\nReturns\n-------\nx:\n    abc\n\n\n\n\nParsed docstring\n\nf_obj.docstring.parsed\n\n[<griffe.docstrings.dataclasses.DocstringSectionText at 0x7eff54623fa0>,\n <griffe.docstrings.dataclasses.DocstringSectionParameters at 0x7eff4c68ca30>,\n <griffe.docstrings.dataclasses.DocstringSectionText at 0x7eff4c68ed40>,\n <griffe.docstrings.dataclasses.DocstringSectionExamples at 0x7eff4c68e530>,\n <griffe.docstrings.dataclasses.DocstringSectionReturns at 0x7eff4c68dae0>]\n\n\nThe docstring into a tree lets us define visitors, which can visit each element and do useful things. For example, print a high-level overview of its structure, or render it to markdown."
  },
  {
    "objectID": "get-started/dev-docstrings.html#previewing-docstrings",
    "href": "get-started/dev-docstrings.html#previewing-docstrings",
    "title": "Inspecting docstrings",
    "section": "Previewing docstrings",
    "text": "Previewing docstrings\nUse the preview function to see the overall structure of a parsed docstring.\n\nfrom quartodoc import get_object, preview\n\nf_obj = get_object(\"quartodoc\", \"get_object\")\n\n\nRaw docstring\n\nprint(f_obj.docstring.value)\n\nFetch a griffe object.\n\nParameters\n----------\npath: str\n    An import path to the object. This should have the form `path.to.module:object`.\n    For example, `quartodoc:get_object` or `quartodoc:MdRenderer.render`.\nobject_name: str\n    (Deprecated). A function name.\nparser: str\n    A docstring parser to use.\nload_aliases: bool\n    For aliases that were imported from other modules, should we load that module?\ndynamic: bool\n    Whether to dynamically import object. Useful if docstring is not hard-coded,\n    but was set on object by running python code.\n\nSee Also\n--------\npreview: print a user-friendly preview of a griffe object.\n\nExamples\n--------\n\n>>> get_function(\"quartodoc\", \"get_function\")\n<Function('get_function', ...\n\nReturns\n-------\nx:\n    abc\n\n\n\n\nPreview\n\npreview(f_obj.docstring.parsed)\n\n█─list\n├─0 = █─DocstringSectionText\n│     ├─kind = <DocstringSectionKind.text: 'text'>\n│     ├─title = None\n│     └─value = 'Fetch a griffe object.'\n├─1 = █─DocstringSectionParameters\n│     ├─kind = <DocstringSectionKind.parameters: 'parameters'>\n│     ├─title = None\n│     └─value = █─list\n│               ├─0 = █─DocstringParameter\n│               │     ├─annotation = Name(source='str', full='str')\n│               │     ├─default = None\n│               │     ├─description = 'An import path to the object. This should have th ...\n│               │     ├─name = 'path'\n│               │     └─value = None\n│               ├─1 = █─DocstringParameter\n│               │     ├─annotation = \"'str | None'\"\n│               │     ├─default = 'None'\n│               │     ├─description = '(Deprecated). A function name.'\n│               │     ├─name = 'object_name'\n│               │     └─value = 'None'\n│               ├─2 = █─DocstringParameter\n│               │     ├─annotation = Name(source='str', full='str')\n│               │     ├─default = \"'numpy'\"\n│               │     ├─description = 'A docstring parser to use.'\n│               │     ├─name = 'parser'\n│               │     └─value = \"'numpy'\"\n│               ├─3 = █─DocstringParameter\n│               │     ├─annotation = None\n│               │     ├─default = 'True'\n│               │     ├─description = 'For aliases that were imported from other modules ...\n│               │     ├─name = 'load_aliases'\n│               │     └─value = 'True'\n│               └─4 = █─DocstringParameter\n│                     ├─annotation = None\n│                     ├─default = 'False'\n│                     ├─description = 'Whether to dynamically import object. Useful if d ...\n│                     ├─name = 'dynamic'\n│                     └─value = 'False'\n├─2 = █─DocstringSectionSeeAlso\n│     ├─kind = <DocstringSectionKindPatched.see_also: 'see also'>\n│     ├─title = 'See Also'\n│     └─value = 'preview: print a user-friendly preview of a griff ...\n├─3 = █─DocstringSectionExamples\n│     ├─kind = <DocstringSectionKind.examples: 'examples'>\n│     ├─title = None\n│     └─value = █─list\n│               └─0 = █─ExampleCode\n│                     └─value = '>>> get_function(\"quartodoc\", \"get_function\")\\n<F ...\n└─4 = █─DocstringSectionReturns\n      ├─kind = <DocstringSectionKind.returns: 'returns'>\n      ├─title = None\n      └─value = █─list\n                └─0 = █─DocstringReturn\n                      ├─name = 'x'\n                      ├─annotation = █─Expression\n                      │              ├─0 = Name(source='dc', full='griffe.dataclasses')\n                      │              ├─1 = '.'\n                      │              └─2 = Name(source='Object', full='griffe.dataclasses.Obj ...\n                      └─description = 'abc'"
  },
  {
    "objectID": "get-started/dev-docstrings.html#parsing-other-docstring-formats",
    "href": "get-started/dev-docstrings.html#parsing-other-docstring-formats",
    "title": "Inspecting docstrings",
    "section": "Parsing other docstring formats",
    "text": "Parsing other docstring formats\nCurrently, quartodoc expects docstrings in the numpydoc format. However, the tool it uses under the hood (griffe) is easy to customize, and supports multiple formats.\nSee the griffe loading docs for instructions. Specifically, the GriffeLoader takes options for customizing docstring parsing."
  },
  {
    "objectID": "get-started/basic-building.html",
    "href": "get-started/basic-building.html",
    "title": "Building and debugging docs",
    "section": "",
    "text": "tl;dr: Once you’ve configured quartodoc in your _quarto.yml file, use the following commands to build and preview a documentation site."
  },
  {
    "objectID": "get-started/basic-building.html#quartodoc-build-create-doc-files",
    "href": "get-started/basic-building.html#quartodoc-build-create-doc-files",
    "title": "Building and debugging docs",
    "section": "quartodoc build: Create doc files",
    "text": "quartodoc build: Create doc files\nAutomatically generate .qmd files with reference api documentation. This is written by default to the reference/ folder in your quarto project.\nquartodoc build\nIf you are iterating on your docstrings while previewing your site with quarto preview, you will likely want to rebuild the doc pages automatically when docstrings change. The --watch flag does exactly this.\nquartodoc build --watch\nFor more information on the quartodoc build command, use --help in the terminal like so:\nquartodoc build --help\n\n\nUsage: quartodoc build [OPTIONS]\n\n  Generate API docs based on the given configuration file  (`./_quarto.yml` by\n  default).\n\nOptions:\n  --config TEXT  Change the path to the configuration file.  The default is\n                 `./_quarto.yml`\n  --filter TEXT  Specify the filter to select specific files. The default is\n                 '*' which selects all files.\n  --dry-run      If set, prevents new documents from being generated.\n  --watch        If set, the command will keep running and watch for changes\n                 in the package directory.\n  --verbose      Enable verbose logging.\n  --help         Show this message and exit."
  },
  {
    "objectID": "get-started/basic-building.html#quartodoc-interlinks-create-inventory-files",
    "href": "get-started/basic-building.html#quartodoc-interlinks-create-inventory-files",
    "title": "Building and debugging docs",
    "section": "quartodoc interlinks: Create inventory files",
    "text": "quartodoc interlinks: Create inventory files\nInventory files facilitate linking to API doc pages within and across quartodoc sites. This is optional.\nquartodoc interlinks"
  },
  {
    "objectID": "get-started/basic-building.html#quarto-preview-preview-the-site",
    "href": "get-started/basic-building.html#quarto-preview-preview-the-site",
    "title": "Building and debugging docs",
    "section": "quarto preview: Preview the site",
    "text": "quarto preview: Preview the site\nUse quarto to preview the site:\nquarto preview"
  },
  {
    "objectID": "get-started/basic-building.html#speeding-up-preview",
    "href": "get-started/basic-building.html#speeding-up-preview",
    "title": "Building and debugging docs",
    "section": "Speeding up preview",
    "text": "Speeding up preview\n\nRewriting doc files\nBy default, the quartodoc build only re-writes doc pages when it detects a change to their content. This helps prevent quarto preview from trying to re-render every doc page–including those that haven’t changed.\n\n\nSelectively building doc pages\nUse the filter option with quartodoc build to generate a subset of doc pages. This is useful when you have a many (e.g. several hundred) doc pages, and want to test a change on a single page.\nquartodoc build --filter 'get_object'\nThis option also accepts a wildcard pattern, which causes it to build docs for all matching objects.\n# write the docs for the MdRenderer class, and any of its methods\n# (e.g. MdRenderer.renderer)\nquartodoc build --filter 'MdRenderer*'\n\n\n\n\n\n\nNote\n\n\n\nWhen using a name with a wildcard, be sure to put it in single quotes! Otherwise, your shell may try to “expand it” to match file names."
  },
  {
    "objectID": "get-started/sidebar.html",
    "href": "get-started/sidebar.html",
    "title": "Sidebar navigation",
    "section": "",
    "text": "quartodoc can generate a sidebar on the lefthand side of the page, with a list of your functions.\nIn order to create a sidebar for your docs, add the following options to your _quarto.yml:\n# tell quarto to read the sidebar file\nmetadata-files:\n  - _sidebar.yml\n\n\n# tell quartodoc to generate the sidebar file\nquartodoc:\n  sidebar: \"_sidebar.yml\"\n  # other options ...\nNote that running python -m quartodoc build will now produce a file called _sidebar.yml, with a quarto sidebar configuration. The quarto metadata-files option ensures it’s included with the configuration in _quarto.yml.\nHere is what the sidebar for the quartodoc reference page looks like:\n\n\nwebsite:\n  sidebar:\n  - contents:\n    - api/index.qmd\n    - contents:\n      - api/Auto.qmd\n      - api/blueprint.qmd\n      - api/collect.qmd\n      - api/get_object.qmd\n      - api/preview.qmd\n      section: Preparation Functions\n    - contents:\n      - api/MdRenderer.qmd\n      - api/MdRenderer.render.qmd\n      - api/MdRenderer.render_annotation.qmd\n      - api/MdRenderer.render_header.qmd\n      - api/MdRenderer.signature.qmd\n      - api/MdRenderer.summarize.qmd\n      section: Docstring Renderers\n    - contents:\n      - api/Builder.qmd\n      - api/Builder.from_quarto_config.qmd\n      - api/Builder.build.qmd\n      - api/Builder.write_index.qmd\n      - api/Builder.write_doc_pages.qmd\n      - api/Builder.write_sidebar.qmd\n      - api/Builder.create_inventory.qmd\n      section: API Builders\n    - contents:\n      - api/create_inventory.qmd\n      - api/convert_inventory.qmd\n      section: Inventory links\n    - contents:\n      - contents:\n        - api/layout.Layout.qmd\n        - api/layout.Section.qmd\n        - api/layout.Page.qmd\n        - api/layout.SectionElement.qmd\n        - api/layout.ContentElement.qmd\n        section: Structural\n      - contents:\n        - api/layout.Doc.qmd\n        - api/layout.DocFunction.qmd\n        - api/layout.DocAttribute.qmd\n        - api/layout.DocModule.qmd\n        - api/layout.DocClass.qmd\n        - api/layout.Link.qmd\n        - api/layout.Item.qmd\n        - api/layout.ChoicesChildren.qmd\n        section: Docable\n      - contents:\n        - api/ast.DocstringSectionSeeAlso.qmd\n        - api/ast.DocstringSectionNotes.qmd\n        - api/ast.DocstringSectionWarnings.qmd\n        - api/ast.ExampleCode.qmd\n        - api/ast.ExampleText.qmd\n        section: Docstring patches\n      section: Data models\n    id: api\n  - id: dummy-sidebar"
  },
  {
    "objectID": "get-started/extra-build-sequence.html",
    "href": "get-started/extra-build-sequence.html",
    "title": "Build sequence diagram",
    "section": "",
    "text": "This sequence diagram shows the process behind quartodoc build. See the API docs for Builder, MdRenderer, and the preperation functions (Auto, blueprint, collect)\n\n\n\n\n\nsequenceDiagram\n    Note left of CLI: _quarto.yml config    \n    CLI->>+Builder: .from_quarto_config()\n    Builder->>MdRenderer: .from_config()\n    MdRenderer-->>Builder: renderer\n    Builder-->>-CLI: builder\n\n\n    CLI->>+Builder: .build()\n\n    Note over Builder: prepare site\n    Builder->>+PrepFunctions: blueprint(self.layout)\n    loop over Auto\n        PrepFunctions->>PrepFunctions: get_object(name)\n    end\n    PrepFunctions-->>Builder: blueprint\n\n    Builder->>PrepFunctions: collect(blueprint)\n    PrepFunctions-->>Builder: pages, items\n\n    Note over Builder: write the site\n    Builder->>+Builder: write_index(blueprint)\n    Builder->>MdRenderer: renderer.summarize(...)\n    Note right of MdRenderer: Describe each object<br>on the index\n    MdRenderer-->>Builder: index content\n\n    Builder->>Builder: write_sidebar(blueprint)\n\n        Builder->>Builder: write_doc_pages(pages)\n    loop over pages\n        Builder->>+MdRenderer: renderer.render(...)\n        MdRenderer->>MdRenderer: .render_header(...)\n        MdRenderer->>MdRenderer: .signature(...)\n        MdRenderer->>MdRenderer: .render_annotation(...)\n        Note right of MdRenderer: for all rendered types\n        opt table of members\n            MdRenderer->>MdRenderer: .summarize(...)      \n        end\n        MdRenderer-->>-Builder: rendered docstring\n    end\n\n    Builder->>Builder: create_inventory(items)"
  },
  {
    "objectID": "get-started/dev-dataclasses.html",
    "href": "get-started/dev-dataclasses.html",
    "title": "Which dataclass do I need?",
    "section": "",
    "text": "Choosing between all the dataclasses\n\ngriffe.dataclasses\ngriffe.docstrings.dataclasses\nquartodoc.ast\nquartodoc.layout"
  }
]